<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从零开始的Linux WiFi CSITool</title>
      <link href="/2021/07/12/cong-ling-kai-shi-de-linux-wifi-csitool/"/>
      <url>/2021/07/12/cong-ling-kai-shi-de-linux-wifi-csitool/</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要参考"><a href="#本文主要参考" class="headerlink" title="本文主要参考"></a>本文主要参考</h1><h3 id="1-官方资料"><a href="#1-官方资料" class="headerlink" title="1.官方资料"></a>1.官方资料</h3><h4 id="1-1-官方Q-amp-A"><a href="#1-1-官方Q-amp-A" class="headerlink" title="1.1 官方Q&amp;A"></a>1.1 官方Q&amp;A</h4><p>链接：<a href="http://dhalperi.github.io/linux-80211n-csitool/faq.html">http://dhalperi.github.io/linux-80211n-csitool/faq.html</a></p><p>点<code>+</code>号看详细信息，重点关注<code>2</code>和<code>13</code></p><h4 id="1-2-官方GitHub"><a href="#1-2-官方GitHub" class="headerlink" title="1.2 官方GitHub"></a>1.2 官方GitHub</h4><p>链接：<a href="https://github.com/dhalperi/linux-80211n-csitool-supplementary/tree/master/injection">https://github.com/dhalperi/linux-80211n-csitool-supplementary/</a></p><h3 id="2-亲测可用安装教程"><a href="#2-亲测可用安装教程" class="headerlink" title="2. 亲测可用安装教程"></a>2. 亲测可用安装教程</h3><h4 id="2-1-灵魂序曲的教程"><a href="#2-1-灵魂序曲的教程" class="headerlink" title="2.1 灵魂序曲的教程"></a>2.1 <strong>灵魂序曲的教程</strong></h4><p>​    虽然有的步骤有些麻烦，但是AP模式亲测可用，monitor模式可能是我驱动没改对，我这里收不到数，但也许教程本身没问题是我的问题。我也没过深究。</p><p>链接： <a href="https://blog.csdn.net/u014645508/article/details/81359409">https://blog.csdn.net/u014645508/article/details/81359409</a></p><h4 id="2-2-沃一德的教程"><a href="#2-2-沃一德的教程" class="headerlink" title="2.2 沃一德的教程"></a>2.2 <strong>沃一德的教程</strong></h4><p>比较精简，但monitor模式博主是亲测可用的。</p><p>链接：<a href="https://blog.csdn.net/qq_20604671/article/details/53996239">https://blog.csdn.net/qq_20604671/article/details/53996239</a></p><h1 id="Linux基础及CSI相关知识的学习"><a href="#Linux基础及CSI相关知识的学习" class="headerlink" title="Linux基础及CSI相关知识的学习"></a>Linux基础及CSI相关知识的学习</h1><h3 id="1-Linux基础"><a href="#1-Linux基础" class="headerlink" title="1. Linux基础"></a>1. Linux基础</h3><h4 id="1-1-视频教程"><a href="#1-1-视频教程" class="headerlink" title="1.1 视频教程"></a>1.1 视频教程</h4><p><strong>兄弟连的linux教程：</strong><a href="https://www.bilibili.com/video/BV1mW411i7Qf">https://www.bilibili.com/video/BV1mW411i7Qf</a><br>看P1-P26左右基本就可以了，看视频虽然更容易理解，但是效率比较低，而且很容易犯困。</p><h4 id="1-2-文字教程"><a href="#1-2-文字教程" class="headerlink" title="1.2 文字教程"></a>1.2 文字教程</h4><p><strong>Cyc的文字教程：</strong><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/Linux.html#%E5%89%8D%E8%A8%80">http://www.cyc2018.xyz/</a><br>无论是什么教程核心，最重要的就是自己敲一遍，看看效果，加深印象！！！！</p><h3 id="2-CSI相关"><a href="#2-CSI相关" class="headerlink" title="2. CSI相关"></a>2. CSI相关</h3><h4 id="2-1-802-11n协议"><a href="#2-1-802-11n协议" class="headerlink" title="2.1 802.11n协议"></a>2.1 802.11n协议</h4><p><strong>IEEE 802.11n协议：</strong><a href="https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=5307322&amp;ref=aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzUzMDczMjI=">https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=5307322</a></p><p>对802.11协议以及802.11n协议有一些初步了解，重点是<code>7-25</code>。</p><h4 id="2-2-CSI简介"><a href="#2-2-CSI简介" class="headerlink" title="2.2 CSI简介"></a>2.2 CSI简介</h4><p>Wi-Fi CSI的那些事：<br><a href="https://blog.csdn.net/nku_zhaolinsheng/article/details/75210563">https://blog.csdn.net/nku_zhaolinsheng/article/details/75210563</a><br>通过读paper已经对CSI肯定有一些了解了，但是这里重点是第一部分，从OSI模型的角度去看获取CSI的原理。</p><h1 id="一、Ubuntu安装"><a href="#一、Ubuntu安装" class="headerlink" title="一、Ubuntu安装"></a>一、Ubuntu安装</h1><p>​    如果我们想要收集CSI数据，首先就需要安装符合要求的操作系统，根据CSI_Tool官方文档，需要安装的系统内核版本要在<code>3.2~4.2</code>之间。</p><p>​    此次我们安装的操作系统为<code>ubuntu-14.04.1</code>，系统内核版本为<code>3.13</code>。</p><p>​    系统下载地址为：<a href="https://pan.baidu.com/s/1eTu0OP8Jb1TwGJFkBZnr1w">https://pan.baidu.com/s/1eTu0OP8Jb1TwGJFkBZnr1w</a> 提取码：oi6x</p><p>​    具体的安装方法自行百度，在此不在赘述。</p><h1 id="二、CSI-Tool安装"><a href="#二、CSI-Tool安装" class="headerlink" title="二、CSI Tool安装"></a>二、CSI Tool安装</h1><p>安装好ubantu系统之后（系统版本和内核版本符合要求），接下来的就是安装<code>CSI_Tools</code>，如果你是按照上面的步骤来进行安装系统，那么接下来就不用有任何的顾虑，直接<code>无脑执行 </code>下面的命令就可以，一个一个的执行，有时候会有一些提示也不要管，那不是错误，总之闭着眼睛执行就行了，大家对比官方的可能觉得我的怎么这么少，因为官方安有很多是为了提示信息啥的，对用功能的实现没有影响，为了简单我都直接跳过了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install gcc make linux-headers-$(uname -r) git-core<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">CSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面一步是去GitHub下载CSI Tool，推荐直接网盘下载。直接在GitHub下载实在是太慢了（毕竟1个多G）！！！</p><p>百度网盘链接：链接: <a href="https://pan.baidu.com/s/15vt73N0PQeJkyvSjSgAU4Q">https://pan.baidu.com/s/15vt73N0PQeJkyvSjSgAU4Q</a> 提取码: bq94 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https://github.com/dhalperi/linux-80211n-csitool.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载之后进行解压</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf /linux-80211n-csitool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进入文件夹</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd linux-80211n-csitool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git checkout ${CSITOOL_KERNEL_TAG}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这一步make编译的时候，会提示<code> Can’t read private key</code>，不必理会，官方也说了没事，可以參考以下官方文档：<a href="https://dhalperi.github.io/linux-80211n-csitool/installation.html%E3%80%82">https://dhalperi.github.io/linux-80211n-csitool/installation.html。</a></p><p>遇到这个问题可以参考：<a href="https://blog.csdn.net/zhangpeterx/article/details/88044404">https://blog.csdn.net/zhangpeterx/article/details/88044404</a></p><p>到此为止环境配置完毕。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="三、AP模式收数"><a href="#三、AP模式收数" class="headerlink" title="三、AP模式收数"></a>三、AP模式收数</h1><h4 id="1-配置MAC"><a href="#1-配置MAC" class="headerlink" title="1.配置MAC"></a>1.配置MAC</h4><p>要求路由器无密码，因为CSI Tool的固件没有足够的代码空间来存储波束成形软件路径（用于测量CSI）和加密软件路径（用于WEP / WPA / WPA2 /等网络）。</p><p>若未修改驱动，需要输入，否则可以跳过</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo modprobe -r iwlwifi mac80211<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步执行之后就已经搜不到无线网了。</p><h4 id="2-配置连接属性"><a href="#2-配置连接属性" class="headerlink" title="2.配置连接属性"></a>2.配置连接属性</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo modprobe iwlwifi connector_log=0x1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步执行之后可以搜到无线网，但是无论是有无密码的都连不上。</p><h4 id="3-配置连接无线网"><a href="#3-配置连接无线网" class="headerlink" title="3.配置连接无线网"></a>3.配置连接无线网</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo killall wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>现在可以连接上不加密的无线网了</code>。</p><h4 id="4-启动工具"><a href="#4-启动工具" class="headerlink" title="4.启动工具"></a>4.启动工具</h4><p>执行下面的命令开始记录数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>csi.dat</code> 是文件名，可任意，他会出现在你的用户目录下，就是你安装这个工具的同级文件夹下。</p><h3 id="5-ping-路由器"><a href="#5-ping-路由器" class="headerlink" title="5.ping 路由器"></a>5.ping 路由器</h3><p>另开一个终端，执行下面的命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo ping 101.6.69.105 -i 0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>101.6.69.105是路由的ip地址，-i 0.2表示发送间隔0.2s，<code>如果间隔小于0.5s需要加上sudo</code>。</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSI数据格式</title>
      <link href="/2021/07/08/csi-shu-ju-ge-shi/"/>
      <url>/2021/07/08/csi-shu-ju-ge-shi/</url>
      
        <content type="html"><![CDATA[<p>数据采集工具csi_tool采集数据并保存为后缀.dat的数据文件，在csi_tool中提供一个c语言函数解析此文件。阅读了c语言的解析代码后发现，数据文件的组织方法与计网中数据十分相似，但略有不同。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>总体上，整个文件仅由n个bfee组成，巧了，数据文件中应当包含有n个采样信息，这个bfee的意义不言而喻，就是和采样一一对应。</p><p>bfee： <a href="https://camo.githubusercontent.com/43b5ba5d76e0c3868f4a7dd393cdd0e0c77d948ff25e1c27f2935a38219647df/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039323934363736382e706e67"><img src="https://camo.githubusercontent.com/43b5ba5d76e0c3868f4a7dd393cdd0e0c77d948ff25e1c27f2935a38219647df/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039323934363736382e706e67"></a></p><p>bfee的数据结构如上图所示。</p><p>前<strong>两字节是field_len</strong>，之后<strong>一字节是code</strong>，再之后便是可变长度的field。<strong>field_len等于code+field的字长</strong>。<br><strong>当code为187时，表示field中是信道信息；</strong></p><p>不是187时，表示field中是其他信息。<br>我们关心的是信道信息，其他信息不解析，跳过该bfee即可。</p><p>field： <a href="https://camo.githubusercontent.com/26e98191e2cd37de9d76d6ecb621ab6f3373f39180ac5d5b9d389e8739874bd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333030393936362e706e67"><img src="https://camo.githubusercontent.com/26e98191e2cd37de9d76d6ecb621ab6f3373f39180ac5d5b9d389e8739874bd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333030393936362e706e67"></a></p><p>若code等于187，field有如上图数据格式。</p><p>到这里你一定感觉很熟悉了。 field分为<strong>头部和有效载荷(payload)<strong>两部分。</strong>头部有20字节</strong>的固定长度，有效载荷是个可变长度，字长为len。</p><p>头部各字段的数据类型和意义如下表：</p><p><a href="https://camo.githubusercontent.com/7c6a93df785699ae494adafbad81e568fbfb249b45daf699e415f6d72875e33e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333032373636372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c316c31595735456157467554773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/7c6a93df785699ae494adafbad81e568fbfb249b45daf699e415f6d72875e33e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333032373636372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c316c31595735456157467554773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"></a></p><p>可以见得，头部中包含了主要的信道信息。</p><p>而其中最重要的<strong>csi矩阵</strong>，分为<strong>30个subc</strong>，保存在<strong>有效载荷</strong>中。分别对应30个子载波。</p><p><strong>subc</strong>的结构如下表所示：</p><p><a href="https://camo.githubusercontent.com/3cc70eec74a7495b549fd2c7978143b2805676883a5f3dd03fe0ee7c25e64fa2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333035373536302e706e67"><img src="https://camo.githubusercontent.com/3cc70eec74a7495b549fd2c7978143b2805676883a5f3dd03fe0ee7c25e64fa2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333035373536302e706e67"></a></p><p><strong>复数</strong>的结构：</p><p><a href="https://camo.githubusercontent.com/68694dc0248c9eec743b54e1ba8aa9ffbc3821a34e580c1eb3211543a4a715c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333131343731392e706e67"><img src="https://camo.githubusercontent.com/68694dc0248c9eec743b54e1ba8aa9ffbc3821a34e580c1eb3211543a4a715c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333131343731392e706e67"></a></p><p><strong>每个subc的开始会有3位的非数据部分</strong>，因此subc的长度不是字节(8位)的整数倍，这将导致subc这部分的解析需要按比特操作，增加我解析工作的复杂度。</p><p>到这里，整个文件的数据结构都清楚了，开始试着用python来解析run-lxx.dat这个文件。</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI数据格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSI安装方法</title>
      <link href="/2021/06/17/csi-an-zhuang/"/>
      <url>/2021/06/17/csi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第一种安装方法"><a href="#一、第一种安装方法" class="headerlink" title="一、第一种安装方法"></a>一、第一种安装方法</h1><h2 id="1-操作系统和硬件配置"><a href="#1-操作系统和硬件配置" class="headerlink" title="1. 操作系统和硬件配置"></a>1. 操作系统和硬件配置</h2><ul><li><h5 id="操作系统：-ubuntu-14-04-3-amd64"><a href="#操作系统：-ubuntu-14-04-3-amd64" class="headerlink" title="操作系统： ubuntu-14.04.3 (amd64)"></a>操作系统： ubuntu-14.04.3 (amd64)</h5><ul><li>系统镜像下载地址： 百度网盘</li></ul><p> 链接：<a href="https://pan.baidu.com/s/1lkI73gSumcvDdBsdB3vyfg">https://pan.baidu.com/s/1lkI73gSumcvDdBsdB3vyfg</a> 提取码：1895</p><ul><li>重装系统方法可参考：<a href="https://blog.csdn.net/weixin_43226231/article/details/100692676">https://blog.csdn.net/weixin_43226231/article/details/100692676</a></li></ul></li><li><h5 id="更换下载源：-最好更换为国内源，推荐阿里源，换源方法可参考：https-blog-csdn-net-qq-35451572-article-details-79516563-biz-id-102-amp-utm-term-ubuntu-E5-9B-BD-E5-86-85-E6-BA-90-amp-utm-medium-distribute-pc-search-result-none-task-blog-2allsobaiduweb-default-0-79516563-amp-spm-1018-2118-3001-4187"><a href="#更换下载源：-最好更换为国内源，推荐阿里源，换源方法可参考：https-blog-csdn-net-qq-35451572-article-details-79516563-biz-id-102-amp-utm-term-ubuntu-E5-9B-BD-E5-86-85-E6-BA-90-amp-utm-medium-distribute-pc-search-result-none-task-blog-2allsobaiduweb-default-0-79516563-amp-spm-1018-2118-3001-4187" class="headerlink" title="更换下载源： 最好更换为国内源，推荐阿里源，换源方法可参考：https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187"></a>更换下载源： 最好更换为国内源，推荐阿里源，换源方法可参考：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187</a></h5></li></ul><h2 id="2-准备工作——发射器接收器都需要的操作"><a href="#2-准备工作——发射器接收器都需要的操作" class="headerlink" title="2. 准备工作——发射器接收器都需要的操作"></a>2. 准备工作——发射器接收器都需要的操作</h2><ul><li><h5 id="在terminal输入以下指令："><a href="#在terminal输入以下指令：" class="headerlink" title="在terminal输入以下指令："></a>在terminal输入以下指令：</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install gcc make linux-headers-$(uname -r) git-coreCSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><h5 id="下载CSITOOL"><a href="#下载CSITOOL" class="headerlink" title="下载CSITOOL"></a>下载CSITOOL</h5><ul><li><p>官方链接：（不推荐）</p><p>git clone <a href="https://github.com/dhalperi/linux-80211n-csitool.git">https://github.com/dhalperi/linux-80211n-csitool.git</a></p></li><li><p>推荐下载链接：百度网盘</p><p>链接：<a href="https://pan.baidu.com/s/1JTfz-wAPU5WLyA_gHynK_Q">https://pan.baidu.com/s/1JTfz-wAPU5WLyA_gHynK_Q</a> 提取码：1895</p></li></ul></li><li><h5 id="接下来执行："><a href="#接下来执行：" class="headerlink" title="接下来执行："></a>接下来执行：</h5><pre class="line-numbers language-none"><code class="language-none">cd linux-80211n-csitoolgit checkout ${CSITOOL_KERNEL_TAG}make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modulessudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo depmodcd ..git clone https://github.com/dhalperi/linux-80211n-csitool-supplementary.gitfor file in /lib/firmware/iwlwifi-5000-*.ucode; do sudo mv $file $file.orig; donesudo cp linux-80211n-csitool-supplementary/firmware/iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/    sudo ln -s iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/iwlwifi-5000-2.ucodemake -C linux-80211n-csitool-supplementary/netlink```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><em>若直接用AP模式的话可执行以下指令：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo modprobe -r iwlwifi mac80211sudo modprobe iwlwifi connector_log=0x1sudo killall wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><em>然后链接上没有密码的路由器，执行：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>打开一个新的终端执行：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo ping 192.168.1.1 -i 0.005<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>这样AP模式就可以开始接收数据了</em></p></li></ul></li><li><h5 id="下载lorcon"><a href="#下载lorcon" class="headerlink" title="下载lorcon:"></a>下载lorcon:</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install libpcap-devgit clone https://github.com/dhalperi/lorcon-old.gitcd lorcon-old./configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-配置Monitor模式"><a href="#3-配置Monitor模式" class="headerlink" title="3. 配置Monitor模式"></a>3. 配置Monitor模式</h2><ul><li><h5 id="将发射器的-linux-80211n-csitool-supplementary-injection目录下的setup-inject-sh-改为以下代码："><a href="#将发射器的-linux-80211n-csitool-supplementary-injection目录下的setup-inject-sh-改为以下代码：" class="headerlink" title="将发射器的**/linux-80211n-csitool-supplementary/injection目录下的setup_inject.sh**改为以下代码："></a>将发射器的**/linux-80211n-csitool-supplementary/injection<strong>目录下的</strong>setup_inject.sh**改为以下代码：</h5><p><em><strong>(以下脚本可自行按需更改)</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/sudo /bin/bashrfkill unblock allmodprobe -r iwlwifi mac80211 cfg80211modprobe iwlwifi debug=0x40000ifconfig wlan0 2&gt;/dev/null 1&gt;/dev/nullwhile [ $? -ne 0 ]do        ifconfig wlan0 2&gt;/dev/null 1&gt;/dev/nulldoneiw dev wlan0 interface add mon0 type monitorsudo ifconfig wlan0 downsudo ifconfig mon0 upiw mon0 set channel $1 $2ifconfig mon0 upsudo chmod 777 /sys/kernel/debug/sudo chmod 777 /sys/kernel/debug/tracing/echo 0x4101 | sudo tee `find /sys -name monitor_tx_rate`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="将接收器的-linux-80211n-csitool-supplementary-injection目录下的setup-monitor-csi-sh-改为以下代码"><a href="#将接收器的-linux-80211n-csitool-supplementary-injection目录下的setup-monitor-csi-sh-改为以下代码" class="headerlink" title="将接收器的**/linux-80211n-csitool-supplementary/injection目录下的setup_monitor_csi.sh**改为以下代码"></a>将接收器的**/linux-80211n-csitool-supplementary/injection<strong>目录下的</strong>setup_monitor_csi.sh**改为以下代码</h5><p><em><strong>(以下脚本可自行按需更改)</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/sudo /bin/bashmodprobe -r iwlwifi mac80211 cfg80211modprobe iwlwifi connector_log=0x1# Setup monitor mode, loop until it worksiwconfig wlan0 mode monitor 2&gt;/dev/null 1&gt;/dev/nullwhile [ $? -ne 0 ]doiwconfig wlan0 mode monitor 2&gt;/dev/null 1&gt;/dev/nulldoneecho "1234444"ifconfig wlan0 upiw wlan0 set channel $1 $2ifconfig wlan0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="在两台机子上都执行以下命令："><a href="#在两台机子上都执行以下命令：" class="headerlink" title="在两台机子上都执行以下命令："></a>在两台机子上都执行以下命令：</h5><pre class="line-numbers language-none"><code class="language-none">cd ~cd linux-80211n-csitool-supplementary/injectionmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="4-启动Monitor模式"><a href="#4-启动Monitor模式" class="headerlink" title="4. 启动Monitor模式"></a>4. 启动Monitor模式</h2><p>在/linux-80211n-csitool-supplementary/injection下执行以下步骤，即先cd /linux-80211n-csitool-supplementary/injection</p><p>发射端：</p><pre class="line-numbers language-none"><code class="language-none"> ./setup_inject.sh 64 HT20sudo ./random_packets 10000 100 1 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接收端</p><pre class="line-numbers language-none"><code class="language-none">./setup_monitor_csi.sh 64 HT20sudo ../netlink/log_to_file log.dat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>如果发射端在重启之后正常启动，但是接收端没有接收到数据的话，就把发射器机子上的/linux-80211n-csitool-supplementary/injection文件夹下的.o文件删掉，然后在该目录下重新make就可以了。</em></p><p>参考文章：<a href="https://blog.csdn.net/bixianren9179/article/details/103802974">https://blog.csdn.net/bixianren9179/article/details/103802974</a></p><p> <a href="https://blog.csdn.net/dfcaihg/article/details/83552072">https://blog.csdn.net/dfcaihg/article/details/83552072</a></p><h1 id="二、另一种安装方法"><a href="#二、另一种安装方法" class="headerlink" title="二、另一种安装方法"></a>二、另一种安装方法</h1><p>用的是第一种方法提供的系统安装镜像文件。</p><p>如果你的硬件和系统都和我的一样，那么接下来就不用有任何顾虑了，直接 无脑执行 下面的命令就可以，一个一个的执行，有时候会有一些提示也不要管，那不是错误，总之闭着眼睛执行就行了，大家对比官方的可能觉得我的怎么这么少，因为官方安有很多是为了提示信息啥的，对用功能的实现没有影响，为了简单我都直接跳过了：</p><pre class="line-numbers language-none"><code class="language-none">1、sudo apt-get install gcc make linux-headers-$(uname -r) git-core2、CSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)3、git clone https://github.com/dhalperi/linux-80211n-csitool.git4、cd linux-80211n-csitool5、git checkout ${CSITOOL_KERNEL_TAG}6、make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modules7、sudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install8、sudo depmod9、cd ..10、git clone https://github.com/dhalperi/linux-80211n-csitool-supplementary.git11、for file in /lib/firmware/iwlwifi-5000-*.ucode; do sudo mv $file $file.orig; done12、sudo cp linux-80211n-csitool-supplementary/firmware/iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/13、sudo ln -s iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/iwlwifi-5000-2.ucode14、make -C linux-80211n-csitool-supplementary/netlink`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中间第三步下载的速度是比较慢的，毕竟是从 github 上面下载 1个多 G 的文件，我原本以为速度很慢，但其实还好，1个小时左右就可以搞定。</p><p>然后在<strong>第7步</strong> make 编译的时候会有提示 <strong>Can’t read private key</strong> ，不要理会，官方也说了没事：<a href="https://dhalperi.github.io/linux-80211n-csitool/installation.html">https://dhalperi.github.io/linux-80211n-csitool/installation.html</a></p><p>遇到这个问题可以参考：<a href="https://blog.csdn.net/zhangpeterx/article/details/88044404">https://blog.csdn.net/zhangpeterx/article/details/88044404</a></p><p>到此为止环境配置完毕。</p><p><strong>1、配置 mac</strong><br><code>sudo modprobe -r iwlwifi mac80211</code><br>这一步执行之后已经搜不到无线网了。</p><p><strong>2、配置连接属性</strong><br><code>sudo modprobe iwlwifi connector_log=0x1</code><br>这一步执行之后可以搜到，但是无论是有无密码的都连不上。</p><p><strong>3、配置连接无线网</strong><br><code>sudo killall wpa_supplicant</code><br>现在可以<strong>连接上不加密的无线网</strong>了。</p><p><strong>4、启动工具</strong><br>执行下面的命令开始记录数据：<code>sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat</code><br>其中 csi.dat 是文件名，可任意，他会出现在你的用户目录下，就是你安装这个工具的同级文件夹下。</p><p><strong>5、ping</strong><br>另开一个终端，执行 <code>ping 192.168.1.1 -i 0.2</code>，其中ip地址是你的路由器网关。</p><p>如果有下图所示的输出就代表成功了。</p><p><img src="/2021/06/17/csi-an-zhuang/Users\Libra\AppData\Roaming\Typora\typora-user-images\image-20210615212010088.png" alt="image-20210615212010088"></p><p><strong>每次启动时的初始化</strong><br>另外每次关机之后就回到了解放前，只需要依次执行下面的命令即可：</p><p><code>sudo modprobe -r iwlwifi mac80211</code></p><p><code>sudo modprobe iwlwifi connector_log=0x1</code></p><p><code>sudo killall wpa_supplicant</code></p><p>你可以把上面的三条命令写成一个脚本，然后再做一个定时任务，每次电脑启动时自动执行就很方便了，我就是这么做的。</p><p>之后点击 wifi 连接你的路由器，最后执行：</p><p><code>sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat</code></p><p>其中 csi.dat 是你要保存的文件名，在用户目录下。</p><p>这个时候他就开始监听了，你直接 ping 路由器就可以获取数据了。</p><p><strong>总结</strong></p><p>我是最近才做的 （2020年5月28日），根据网上 某个亲测可用的教程 👆 做的，不过那个教程确实写得太麻烦了，于是我为了避免别人踩坑，总结了一下做法，希望对大家有帮助，如果你遇到困难或者问题可以在下方留言，我会在一天之内回复。</p><p>另外可视化的操作看这里：</p><p><a href="https://blog.csdn.net/u014645508/article/details/82887470">https://blog.csdn.net/u014645508/article/details/82887470</a><br>————————————————</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI_Tools安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session，sessionStorage，localStorage的解释以及区别</title>
      <link href="/2021/05/20/session-localstorage-sessionstorage-de-qu-bie/"/>
      <url>/2021/05/20/session-localstorage-sessionstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Web-Storage介绍"><a href="#一、Web-Storage介绍" class="headerlink" title="一、Web Storage介绍"></a>一、Web Storage介绍</h3><p>HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，<code>Web Storage存储机制</code>是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。</p><p>​        我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据<code>存在以下几个问题</code>：</p><ol><li><p>大小：cookie的大小被限制在4KB。</p></li><li><p>带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。</p></li><li><p>复杂性：要正确的操纵cookie是很困难的。</p></li></ol><p>针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是<code>Web Storage</code>。</p><h3 id="二、sessionStorage-和-localStorage"><a href="#二、sessionStorage-和-localStorage" class="headerlink" title="二、sessionStorage 和 localStorage"></a>二、sessionStorage 和 localStorage</h3><p>具体来说，Web Storage又分为两种：<code>sessionStorage</code> 和 <code>localStorage</code>。</p><p>​    （1）localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p><p>​    （2）sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。</p><p>​    这两者的区别在于：<strong>sessionStorage为临时保存，而localStorage为永久保存</strong>。</p><p>​    到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。</p><h3 id="三、sessionStorage和localStorage的使用："><a href="#三、sessionStorage和localStorage的使用：" class="headerlink" title="三、sessionStorage和localStorage的使用："></a>三、sessionStorage和localStorage的使用：</h3><p>（1）创建一个本地存储的<code>键值对</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名和键值作为参数，将会把键值添加到存储中，如果键名存在，则会更新其对应的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）获取数据，将键值传入，即可获取到对应的value值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> sessiondata <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> localdata <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名作为参数，返回键名对应的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）删除单个数据，根据键值移除对应的信息。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名作为参数，并把该键名从存储中删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）删除所有的数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//调用该方法会清空存储中的所有键名。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ol><li><p>Cookie，sessionStorage，localStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的<strong>键值对</strong>！</p></li><li><p>sessionStorage和session不是一个概念！！！</p><p>在<strong>服务端</strong>有一种存储方式叫做：session会话存储，常常简称session。</p><p>sessionStorage和localStorage都是浏览器本地存储，统称为Web 存储，存储内容的大小一般支持5-10MB，浏览器通过<code>window.sessionStorage</code> 和 <code>window.localStorage</code>属性来实现本地存储机制。</p><p><strong>说明：</strong></p><ul><li><p>sessionStorage存储的内容会随着浏览器窗口的关闭而消失。</p></li><li><p>localStorage存储的内容，需要手动清除才会消失。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> localStorage </tag>
            
            <tag> sessionStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORM介绍</title>
      <link href="/2021/05/16/orm-jie-shao/"/>
      <url>/2021/05/16/orm-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ORM介绍"><a href="#一、ORM介绍" class="headerlink" title="一、ORM介绍"></a>一、ORM介绍</h2><h3 id="1-什么是ORM"><a href="#1-什么是ORM" class="headerlink" title="1. 什么是ORM"></a>1. 什么是ORM</h3><ul><li><strong><code>ORM</code></strong> 全拼<code>Object-Relation Mapping</code>.</li><li>中文意为 <strong><code>对象-关系映射</code></strong>.</li><li>在<code>MVC</code>/<code>MVT</code>设计模式中的<code>Model</code>模块中都包括<code>ORM</code></li></ul><h3 id="2-ORM优势"><a href="#2-ORM优势" class="headerlink" title="2.ORM优势"></a>2.ORM优势</h3><p>（1）只需要面向对象编程, 不需要面向数据库编写代码。</p><ul><li>对数据库的操作都转化成对类属性和方法的操作。</li><li>不用编写各种数据库的sql语句。</li></ul><p>（2）实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异。</p><ul><li>不再关注用的是mysql、oracle…等。</li><li>通过简单的配置就可以轻松更换数据库, 而不需要修改代码。</li></ul><h3 id="3-ORM劣势"><a href="#3-ORM劣势" class="headerlink" title="3.ORM劣势"></a>3.ORM劣势</h3><p>（1）相比较直接使用SQL语句操作数据库，有性能损失。</p><p>（2）根据对象的操作转换成SQL语句，根据查询的结果转化为对象，在映射过程中有性能损失。</p><h3 id="4-ORM和数据库关系："><a href="#4-ORM和数据库关系：" class="headerlink" title="4.ORM和数据库关系："></a>4.ORM和数据库关系：</h3><p>在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表.</p><p>基本情况：</p><p>每个模型都是一个Python类，它是<code>django.db.models.Model</code>的子类。模型的每个属性都代表一个数据库字段。</p><p>综上所述，Django为您提供了一个自动生成的数据库访问API。</p><p><img src="/2021/05/16/orm-jie-shao/blog\myblog\source_posts\imgs\ORM.png" alt="ORM和数据库对应关系"></p><h2 id="二、ORM用法"><a href="#二、ORM用法" class="headerlink" title="二、ORM用法"></a>二、ORM用法</h2><h3 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h3><p>**<code>属性名 = models.字段类型,</code>**定义属性时需要指定字段类型, 通过字段类型的参数指定选项</p><p>属性名</p><ul><li>不允许使用python的保留关键字</li><li>不允许使用mysql的保留关键字</li><li>不允许使用连续的下划线，因为Django的查询语法就是连续的下划线</li></ul><p><code>AutoField</code>：自动增长的<code>IntegerField</code>, 不指定时Django会自动创建属性名为id的自动增长属性</p><p><code>BooleanField</code>：布尔字段，值为True或False</p><p><code>NullBooleanField</code>：支持Null、True、False三种值</p><p><code>CharField(max_length=20)</code>：字符串</p><ul><li>参数max_length表示最大字符个数</li></ul><p><code>TextFiled</code>：大文本字段，一般超过4000个字符时使用</p><p><code>IntegerField</code>：整数</p><p><code>DecimalField(max_digits=None, decimal_places=None)</code>：可以指定精度的十进制浮点数</p><ul><li>参数max_digits表示总位数</li><li>参数decimal_places表示小数位数</li></ul><p><code>FloatField()</code>：浮点数 </p><p><code>DateField[auto_now=False, auto_now_add=False])</code>：日期</p><ul><li>参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为false</li><li>参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false</li><li>参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</li></ul><p><code>TimeField</code>：参数和DateField一样</p><p><code>DateTimeField</code>：日期时间，参数同DateField</p><p><code> FileField</code>：上传文件字段，以二进制的形式</p><p> <code>ImageField</code>：继承于FileField，对上传的内容进行校验，确保是有效的图片</p><h3 id="2-字段选项："><a href="#2-字段选项：" class="headerlink" title="2.字段选项："></a>2.字段选项：</h3><p><code>null</code>：如果为True，表示允许为空，默认值是False</p><p><code>blank</code>：如果为True，则该字段允许为空白，默认值是False    </p><ul><li>对比：null是数据库范畴的概念，blank是表单验证范畴的</li></ul><p><code>db_column</code>：字段的名称，如果未指定，则使用属性的名称（只限于数据库表中的名字，操作数据库还是类属性的名字）</p><p><code>db_index</code>：若值为True, 则在表中会为此字段创建索引，默认值是False（为了优化查询速度 ）</p><p><code>default</code>：默认值，这可以是值或可调用对象。如果可调用，则每次创建新对象时都会调用它。</p><p><code>primary_key</code>：若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</p><p><code>unique</code>：如果为True, 这个字段在表中必须有唯一值，这个值不能重复，默认值是False</p><p>关系型字段类型:关联表中使用</p><p><strong>注意：Django会自动为表创建主键字段</strong></p><ul><li>如果使用选项设置某属性为主键字段后，Django不会再创建自动增长的主键字段</li><li>默认创建的主键字段为<code>id</code>，可以使用<code>pk</code>代替，pk全拼为<code>primary key</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#人物姓名</span>    gender <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#人物性别</span>    description <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#人物描述</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>    book <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>BookInfo<span class="token punctuation">)</span> <span class="token comment"># 外键约束，人物属于哪本书</span>    pub_date <span class="token operator">=</span> models<span class="token punctuation">.</span>DateField<span class="token punctuation">(</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#日期</span>    readcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#阅读量</span>    commentcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#评论量</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>     <span class="token comment"># 元类信息 : 修改表名</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        db_table <span class="token operator">=</span> <span class="token string">'people_info'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-关系字段类型"><a href="#3-关系字段类型" class="headerlink" title="3.关系字段类型"></a>3.关系字段类型</h3><ul><li>关系型数据库的关系包括三种类型：<ul><li>ForeignKey：一对多，将字段定义在多的一端中</li><li>ManyToManyField：多对多，将字段定义在任意一端中</li><li>OneToOneField：一对一，将字段定义在任意一端中</li></ul></li><li>可以维护递归的关联关系，使用<code>self</code>指定</li></ul><h3 id="4-元选项"><a href="#4-元选项" class="headerlink" title="4.元选项"></a>4.元选项</h3><p><strong>作用</strong>：修改数据库表的默认的名称</p><p>数据库表的默认名称为 :</p><pre class="line-numbers language-none"><code class="language-none">应用名_模型名例：Book应用中定义BookInfo模型类Book_bookinfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在模型类中定义<code>元类Meta</code>，用于设置元信息，使用<code>db_table</code>自定义表的名字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 书籍信息模型</span><span class="token keyword">class</span> <span class="token class-name">BookInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#图书名称</span>     <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span> <span class="token comment">#元信息类</span>        db_table <span class="token operator">=</span> <span class="token string">'bookinfo'</span> <span class="token comment">#自定义表的名字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-模型成员"><a href="#5-模型成员" class="headerlink" title="5.模型成员"></a>5.模型成员</h3><p><strong><code>objects</code> : 管理器对象</strong></p><ul><li>是**<code>Manager</code><strong>类型的对象，定义在</strong><code>from django.db import models</code>**中</li><li>用于模型对象和数据库交互</li><li>是默认自动生成的属性，但是可以自定义管理器对象</li><li>自定义管理器对象后，Django不再生成默认管理器对象**<code>objects</code>**</li></ul><p><strong>自定义管理器对象</strong></p><p>为模型类<code>UserInfo</code>自定义管理器对象<code>Users</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 用户信息模型</span><span class="token keyword">class</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#名称</span>    pub_date <span class="token operator">=</span> models<span class="token punctuation">.</span>DateField<span class="token punctuation">(</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#日期</span>    readcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#阅读量</span>    commentcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#评论量</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>     <span class="token comment">#元类信息 : 修改表名</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        db_table <span class="token operator">=</span> <span class="token string">'Userinfo'</span>     <span class="token comment"># 自定义管理器对象</span>    Users <span class="token operator">=</span> models<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义管理器对象后，查询数据时直接使用 <code>Users </code>查询,不再用默认的<code>objects</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 书籍列表信息视图</span>  <span class="token keyword">def</span> <span class="token function">userList</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment"># 查询数据库用户信息 : 默认管理器对象--objects</span>      <span class="token comment"># UserInfos = UserInfo.objects.all()</span>       <span class="token comment"># 查询数据库用户信息 : 自定义管理器对象--Users</span>     UserInfos <span class="token operator">=</span> UserInfo<span class="token punctuation">.</span>Users<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment"># 构造上下文</span>      context <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Userlist'</span><span class="token punctuation">:</span>UserInfos<span class="token punctuation">}</span>       <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'User/Userlist.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Manager：管理器类</strong></p><ul><li>定义在**<code>from django.db import models</code>**中</li><li>管理器是Django的模型进行数据库操作的接口，Django应用的每个模型都拥有至少一个管理器</li><li>Django模型支持自定义管理器类，继承自**<code>models.Manager</code>**</li><li>自定义管理器类主要用于两种情况<ul><li>(1)修改原始查询集，重写<code>get_queryset()</code>方法<ul><li>查询时，如果需要默认过滤掉某些数据，需要修改原始查询集</li></ul></li><li>(2)新增管理器方法，如创建模型对象方法<ul><li>当模型属性很多，多数字段为默认值，每次只需要给少数属性赋值时，可以新增模型初始化方法</li></ul></li></ul></li></ul><p><strong>自定义管理器类：1.修改原始查询集</strong></p><p>把<code>peopleinfo</code>表中的<code>isDelete</code>字段修改为<code>True(updata peopleinfo set isDelete=1 where id=4)</code>,但是逻辑删除字段为<code>True</code>的那条记录依然会被查询出来，这里的解决办法是自定义管理器类，重写<code>get_queryset()</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from django.db import models # 自定义管理器类class PeopleInfoManager(models.Manager):    # 自定义管理器类场景一：重写get_queryset()方法    def get_queryset(self):        # 调用父类的成员语法为：super(子类型, self).成员        # 默认只查询逻辑删除字段为False的记录        return super(PeopleInfoManager, self).get_queryset().filter(isDelete=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义管理器类：2.新增管理器方法</strong></p><p>新增管理器初始化模型对象方法：只有<code>name</code>属性需要赋值，其他的字段都是默认值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># models.py -- 自定义管理器类</span> <span class="token keyword">class</span> <span class="token class-name">UserInfoManager</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Manager<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment"># 自定义管理器类场景一：重写get_queryset()方法</span>     <span class="token keyword">def</span> <span class="token function">get_queryset</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># 调用父类的成员语法为：super(子类型, self).成员</span>         <span class="token comment"># 默认只查询逻辑删除字段为False的记录</span>         <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span>UserInfoManager<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>get_queryset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>isDelete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 初始化模型对象方法</span>     <span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>         user <span class="token operator">=</span> UserInfo<span class="token punctuation">(</span><span class="token punctuation">)</span>         user<span class="token punctuation">.</span>name <span class="token operator">=</span> name         user<span class="token punctuation">.</span>pub_date <span class="token operator">=</span> <span class="token string">'1989-11-11'</span>         user<span class="token punctuation">.</span>readcount <span class="token operator">=</span> <span class="token number">0</span>         user<span class="token punctuation">.</span>commentcount <span class="token operator">=</span> <span class="token number">0</span>         user<span class="token punctuation">.</span>isDelete <span class="token operator">=</span> <span class="token boolean">False</span>         <span class="token keyword">return</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># view.py -- User列表信息视图</span><span class="token keyword">def</span> <span class="token function">UserList</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment"># 初始化模型对象：自定义管理器类后</span>    UserInfos <span class="token operator">=</span> <span class="token punctuation">[</span>        UserInfo<span class="token punctuation">.</span>user<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        UserInfo<span class="token punctuation">.</span>user<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token string">'小杰'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>     <span class="token comment"># 构造上下文</span>    context <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Userlist'</span><span class="token punctuation">:</span>UserInfos<span class="token punctuation">}</span>     <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'User/userlist.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/04/24/she-ji-mo-shi/"/>
      <url>/2021/04/24/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、MVC设计模式"><a href="#一、MVC设计模式" class="headerlink" title="一、MVC设计模式"></a>一、MVC设计模式</h3><p><code>MVC</code>是<code>Model-View-Controller</code>的缩写。其中每个单词都有其不同的含义：</p><ul><li><code>Model</code>代表数据存储层，是对数据的定义和数据的CRUD（增删改查）。<ul><li>增加(Create)、检索(Retrieve)、更新(Update)和删除(Delete)</li></ul></li><li><code>View </code>代表视图层，是系统前端显示的部分，它负责显示什么和如何进行显示。</li><li><code>Controller </code>代表控制层，负责根据从View层输入的指令来检索Model层的数据，并在该层编写代码产生结果并输出。</li></ul><img src="/2021/04/24/she-ji-mo-shi/mvc.png" alt="MVC设计模式示意图" style="zoom:80%;"><p><code>MVC</code>设计模式的请求和响应过程描述如下：</p><ul><li>用户通过浏览器发起<code>request</code>请求，<code>Controller</code>层接受请求后，同时向<code>Model</code>层和<code>View</code>层发送指令；</li><li><code>Model</code>层根据指令与数据库交互并选择相应的业务数据，然后将数据发送给<code>Controller</code>层；</li><li><code>View</code>层接受到<code>Controller</code>层的指令后，加载用户请求的界面，并将页面发送给<code>Controller</code>层；</li><li><code>Controller</code>层接收到<code>Model</code>层和<code>View</code>层的数据后，把它们组织成响应格式发送给浏览器，浏览器通过解析后把页面显示出来。</li></ul><p>​    MVC 的 3 层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC 的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是 MVC 的设计模式。</p><h3 id="二、MTV设计模式"><a href="#二、MTV设计模式" class="headerlink" title="二、MTV设计模式"></a>二、MTV设计模式</h3><p>那么 Django（栈go）的 MTV 又是怎么回事呢？下面讲解 <code>Django </code>的设计模式。</p><p>Django 借鉴了经典的 MVC 模式，它也将交互的过程分为了 3 个层次，也就是 MTV 设计模式；</p><ul><li><p><code>Model</code>：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；</p></li><li><p><code>Template</code>：模板层（也叫表现层）具体来处理页面的显示；</p></li><li><p><code>View</code>：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。</p></li></ul><img src="/2021/04/24/she-ji-mo-shi/mtv.png" alt="Django MTV设计模式示意图" style="zoom:80%;"><p>我们按照 MVC 的设计模式对 MTV 进行分析，<strong>MTV 设计模式中，用 <code>View </code>层取代了 <code>Controller</code> 层的位置，用 <code>Template</code> 层取代了原来<code>View</code>层的位置。</strong></p><p>初次接触 Django 的设计模式的人，可能会对 Template 层产生疑问，其实 Template 英文的含义就是“模板”的意思，你可以简单理解成，它是一个 HTML 页面 ，HTML 页面的渲染在视图层完成。</p><p>同样我们也对 MTV 设计模式的请求与响应过程进行描述：</p><ul><li><p>用户通过浏览器对服务器发起 <code>request </code>请求，服务器接收请求后，通过 <code>View </code>的业务逻辑层进行分析，同时向 <code>Model </code>层和 <code>Template </code>层发送指令；</p></li><li><p><code>Mole </code>层与数据库进行交互，将数据返回给 <code>View </code>层；</p></li><li><p><code>Template </code>层接收到指令后，调用相应的模板，并返回给 <code>View </code>层；</p></li><li><p><code>View </code>层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。</p></li></ul><p>​     通过以上两种设计模式的比较， 我们可以得出 <strong>MTV 是 MVC 的一种细化</strong>，将原来 MVC 中的 V 层拿出来进行分离，视图的显示与如何显示交给 Template 层，而 View 层更专注于实现业务逻辑。其实在 Django 是有 Controller 层的，只不过它由框架本身来实现，所以我们不用关心它。Django 更关注于M、T 和 V。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DJANGO块标签{ %BLOCK NAME% }{ %ENDBLOCK% }的理解</title>
      <link href="/2021/03/15/django-kuai-biao-qian-block-name-endblock-de-li-jie/"/>
      <url>/2021/03/15/django-kuai-biao-qian-block-name-endblock-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>举个例子来理解吧。</p><p>（1）首先，先建立一个<code>apple.html</code>文件，内容如下:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zn-CN<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            {% block content %}            {% endblock %}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）再建立一个<code>boom.html</code>文件,内容如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">{% extend 'apple.html' %}{% block content %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>            Django 块标签的理解        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>{% endblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么输出的网页就会变成如下。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zn-CN<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>            Django 块标签的理解        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，就是<code>boom.html</code>的块标签里面的内容完全代替了<code>apple.html</code>里面的块标签。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django  块标签  {% block name%}{endblock} </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
