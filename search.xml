<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试官：你了解Vue的diff算法吗？说说看</title>
      <link href="/2021/08/24/vue/diff/"/>
      <url>/2021/08/24/vue/diff/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：你了解vue的diff算法吗？说说看"><a href="#面试官：你了解vue的diff算法吗？说说看" class="headerlink" title="面试官：你了解vue的diff算法吗？说说看"></a>面试官：你了解vue的diff算法吗？说说看</h1><p><img src="https://static.vue-js.com/5e858e30-4585-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li></ul><p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p><h2 id="二、比较方式"><a href="#二、比较方式" class="headerlink" title="二、比较方式"></a>二、比较方式</h2><p><code>diff</code>整体策略为：深度优先，同层比较</p><ol><li>比较只会在同层级进行, 不会跨层级比较</li></ol><img src="https://static001.infoq.cn/resource/image/91/54/91e9c9519a11caa0c5bf70714383f054.png" alt="img" style="zoom:50%;"><ol start="2"><li>比较的过程中，循环从两边向中间收拢</li></ol><img src="https://static001.infoq.cn/resource/image/2d/ec/2dcd6ad5cf82c65b9cfc43a27ba1e4ec.png" alt="img" style="zoom:50%;"><p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p><p>新旧<code>VNode</code>节点如下图所示：</p><p><img src="https://static001.infoq.cn/resource/image/80/6d/80dc339f73b186479e6d1fc18bfbf66d.png"></p><p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p><p><img src="https://static001.infoq.cn/resource/image/76/54/76032c78c8ef74047efd42c070e48854.png"></p><p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p><p><img src="https://static001.infoq.cn/resource/image/1c/d7/1c76e7489660188d35f0a38ea8c8ecd7.png"></p><p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p><p><img src="https://static001.infoq.cn/resource/image/4b/08/4b622c0d61673ec5474465d82305d308.png"></p><p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code> startIndex</code> 移动到了 B</p><p><img src="https://static001.infoq.cn/resource/image/59/b4/5982417c3e0b2fa9ae940354a0e67ab4.png"></p><p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex </code>移动到了 C，新节点的 startIndex 移动到了 F</p><p><img src="https://static001.infoq.cn/resource/image/16/86/16cf0ef90f6e19d26c0ddffeca067e86.png"></p><p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p><p><img src="https://static001.infoq.cn/resource/image/dc/ad/dc215b45682cf6c9cc4700a5425673ad.png"></p><h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p><p>源码位置：src/core/vdom/patch.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 没有新节点，直接执行destory钩子函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> isInitialPatch <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">const</span> insertedVnodeQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        isInitialPatch <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span> <span class="token comment">// 没有旧节点，直接用新节点生成dom元素</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> isRealElement <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>nodeType<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRealElement <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span>            <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isRealElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> oldVnode<span class="token punctuation">.</span><span class="token function">hasAttribute</span><span class="token punctuation">(</span><span class="token constant">SSR_ATTR</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oldVnode<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span><span class="token constant">SSR_ATTR</span><span class="token punctuation">)</span>                    hydrating <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>hydrating<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hydrate</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">invokeInsertHook</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> oldVnode                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                oldVnode <span class="token operator">=</span> <span class="token function">emptyNodeAt</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> vnode<span class="token punctuation">.</span>elm        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p><ul><li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li><li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode </code>去处理这两个节点</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ul><p>下面主要讲的是<code>patchVnode</code>部分</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patchVnode</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果新旧节点一致，什么都不做</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span>    <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm    <span class="token comment">// 异步占位符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>resolved<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">hydrate</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        vnode<span class="token punctuation">.</span>isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">true</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果新旧都是静态节点，并且具有相同的key</span>    <span class="token comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span>    <span class="token comment">// 也不用再有其他操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>isStatic<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token function">isTrue</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>isStatic<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      vnode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVnode<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>      <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>isCloned<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isTrue</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>isOnce<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>componentInstance      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> i    <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>prepatch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children    <span class="token keyword">const</span> ch <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPatchable</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果vnode不是文本节点或者注释节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 并且都有子节点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 并且子节点不完全一致，则调用updateChildren</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>        <span class="token comment">// 如果只有新的vnode有子节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>        <span class="token comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span>        <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>        <span class="token comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// 如果老节点是文本节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment">// 如果新vnode和老vnode是文本节点或注释节点</span>      <span class="token comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>      nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>postpatch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>patchVnode</code>主要做了几个判断：</p><ul><li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li><li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li></ul><p>子节点不完全一致，则调用<code>updateChildren</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateChildren</span> <span class="token punctuation">(</span><span class="token parameter">parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 旧头索引</span>    <span class="token keyword">let</span> newStartIdx <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 新头索引</span>    <span class="token keyword">let</span> oldEndIdx <span class="token operator">=</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// 旧尾索引</span>    <span class="token keyword">let</span> newEndIdx <span class="token operator">=</span> newCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// 新尾索引</span>    <span class="token keyword">let</span> oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// oldVnode的第一个child</span>    <span class="token keyword">let</span> oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>oldEndIdx<span class="token punctuation">]</span> <span class="token comment">// oldVnode的最后一个child</span>    <span class="token keyword">let</span> newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// newVnode的第一个child</span>    <span class="token keyword">let</span> newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token punctuation">]</span> <span class="token comment">// newVnode的最后一个child</span>    <span class="token keyword">let</span> oldKeyToIdx<span class="token punctuation">,</span> idxInOld<span class="token punctuation">,</span> vnodeToMove<span class="token punctuation">,</span> refElm    <span class="token comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span>    <span class="token comment">// to ensure removed elements stay in correct relative positions</span>    <span class="token comment">// during leaving transitions</span>    <span class="token keyword">const</span> canMove <span class="token operator">=</span> <span class="token operator">!</span>removeOnly    <span class="token comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 如果oldVnode的第一个child不存在</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// oldStart索引右移</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span> <span class="token comment">// Vnode has been moved left</span>      <span class="token comment">// 如果oldVnode的最后一个child不存在</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// oldEnd索引左移</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>      <span class="token comment">// oldStartVnode和newStartVnode是同一个节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>      <span class="token comment">// oldEndVnode和newEndVnode是同一个节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>      <span class="token comment">// oldStartVnode和newEndVnode是同一个节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Vnode moved right</span>        <span class="token comment">// patch oldStartVnode和newEndVnode</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>        <span class="token comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span>        canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> nodeOps<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// oldStart索引右移，newEnd索引左移</span>        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>      <span class="token comment">// 如果oldEndVnode和newStartVnode是同一个节点</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Vnode moved left</span>        <span class="token comment">// patch oldEndVnode和newStartVnode</span>        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>        <span class="token comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span>        canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>        <span class="token comment">// oldEnd索引左移，newStart索引右移</span>        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>      <span class="token comment">// 如果都不匹配</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldKeyToIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>        <span class="token comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span>        idxInOld <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">)</span>          <span class="token operator">?</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>          <span class="token operator">:</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>        <span class="token comment">// 如果未找到，说明newStartVnode是一个新的节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>idxInOld<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// New element</span>          <span class="token comment">// 创建一个新Vnode</span>          <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>        <span class="token comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          vnodeToMove <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>          <span class="token comment">/* istanbul ignore if */</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vnodeToMove<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">warn</span><span class="token punctuation">(</span>              <span class="token string">'It seems there are duplicate keys that is causing an update error. '</span> <span class="token operator">+</span>              <span class="token string">'Make sure each v-for item has a unique key.'</span>            <span class="token punctuation">)</span>          <span class="token punctuation">}</span>          <span class="token comment">// 比较两个具有相同的key的新节点是否是同一个节点</span>          <span class="token comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// patch vnodeToMove和newStartVnode</span>            <span class="token function">patchVnode</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>            <span class="token comment">// 清除</span>            oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>            <span class="token comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span>            <span class="token comment">// 移动到oldStartVnode.elm之前</span>            canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> vnodeToMove<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>          <span class="token comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// same key but different element. treat as new element</span>            <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// 右移</span>        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code>循环主要处理了以下五种情景：</p><ul><li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li><li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li><li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li><li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul><li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode </code>，同时将这个真实 <code>dom </code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li><li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</li><li>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</li><li><code>patchVnode</code>做了以下操作：<ul><li>找到对应的真实<code>dom</code>，称为<code>el</code></li><li>如果都有都有文本节点且不相等，将<code>el</code>文本节点设置为<code>Vnode</code>的文本节点</li><li>如果<code>oldVnode</code>有子节点而<code>VNode</code>没有，则删除<code>el</code>子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>VNode</code>有，则将<code>VNode</code>的子节点真实化后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点</li></ul></li><li><code>updateChildren</code>主要做了以下操作：<ul><li>设置新旧<code>VNode</code>的头尾指针</li><li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6881907432541552648#heading-1">https://juejin.cn/post/6881907432541552648#heading-1</a></li><li><a href="https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f">https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官：有使用过Vue吗?说说对Vue的理解</title>
      <link href="/2021/08/24/vue/"/>
      <url>/2021/08/24/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：有使用过vue吗？说说你对vue的理解"><a href="#面试官：有使用过vue吗？说说你对vue的理解" class="headerlink" title="面试官：有使用过vue吗？说说你对vue的理解"></a>面试官：有使用过vue吗？说说你对vue的理解</h1><p><img src="https://static.vue-js.com/02ac1620-3ac6-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、从历史说起"><a href="#一、从历史说起" class="headerlink" title="一、从历史说起"></a>一、从历史说起</h2><p>Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解</p><ul><li>石器时代</li><li>文明时代</li><li>工业革命时代</li><li>百花齐放时代</li></ul><h3 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h3><p>石器时代指的就是我们的静态网页，可以欣赏一下1997的Apple官网</p><p> <img src="https://static.vue-js.com/1734e450-3ac6-11eb-85f6-6fac77c0c9b3.png"></p><p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互，如当时的Google（1998年）</p><p> <img src="https://static.vue-js.com/23189000-3ac6-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="文明时代"><a href="#文明时代" class="headerlink" title="文明时代"></a>文明时代</h3><p>ASP，JSP大家应该都不会太陌生，最早出现于 2005 年左右，先后出现了微软的 ASP 和 Java Server Pages [JSP] 等技术,取代了 CGI ，增强了 WEB 与服务端的交互的安全性，类似于下面这样，其实就是Java + HTML</p><p>`&lt;%@&nbsp;page&nbsp;language=”java”&nbsp;contentType=”text/html;&nbsp;charset=utf-8”<br>&nbsp;&nbsp;&nbsp;&nbsp;pageEncoding=”utf-8”%&gt;<br>  </p>    &nbsp;&nbsp;<meta charset="utf-8">  &nbsp;&nbsp;<title>JSP&nbsp;demo</title>  </meta charset="utf-8">    &nbsp;&nbsp;<img src="http: localhost:8080="" web05_session="" 1.jpg" width="200&nbsp;height=100&nbsp;/">  </img src="http:>    `<p>JSP有一个很大的缺点，就是不太灵活，因为JSP是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回渲染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣在这种情况下，同年：Ajax火了(小细节，这里为什么说火了，因为 Ajax 技术并不是 2005 年出现的，他的雏形是 1999 年)，现在看来很常见的技术手段，在当时可是珍贵无比</p><h3 id="工业革命时代"><a href="#工业革命时代" class="headerlink" title="工业革命时代"></a>工业革命时代</h3><p>到这里大家就更熟悉了，移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度，我们可以称之其为工业时代</p><h3 id="百花齐放时代"><a href="#百花齐放时代" class="headerlink" title="百花齐放时代"></a>百花齐放时代</h3><p>这里没有文字，放一张图感受一下</p><p> <img src="https://static.vue-js.com/32a6f430-3ac6-11eb-85f6-6fac77c0c9b3.png"></p><p>PS：这里为什么要说这么多Web的历史，我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？我们接着往下看</p><h2 id="二、vue是什么"><a href="#二、vue是什么" class="headerlink" title="二、vue是什么"></a>二、vue是什么</h2><p>Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互PS: Vue作者尤雨溪是在为AngularJS工作之后开发出了这一框架。他声称自己的思路是提取Angular中为自己所喜欢的部分，构建出一款相当轻量的框架最早发布于2014年2月</p><h2 id="三、Vue核心特性"><a href="#三、Vue核心特性" class="headerlink" title="三、Vue核心特性"></a>三、Vue核心特性</h2><h3 id="数据驱动（MVVM"><a href="#数据驱动（MVVM" class="headerlink" title="数据驱动（MVVM)"></a>数据驱动（MVVM)</h3><p><code>MVVM</code>表示的是 <code>Model-View-ViewModel</code></p><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li></ul><p>这时候需要一张直观的关系图，如下<br> <img src="https://static.vue-js.com/4402c560-3ac6-11eb-85f6-6fac77c0c9b3.png" alt="image.png"></p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件2.组件化的优势</p><ul><li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li><li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li><li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li></ul><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><ul><li><p>常用的指令</p><ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li></ul></li></ul><p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p><h2 id="四、Vue跟传统开发的区别"><a href="#四、Vue跟传统开发的区别" class="headerlink" title="四、Vue跟传统开发的区别"></a>四、Vue跟传统开发的区别</h2><p>没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下</p><p> <img src="https://static.vue-js.com/5ae84840-3ac6-11eb-ab90-d9ae814b240d.png"></p><p>用<code>jquery</code>来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..)</p><p> <img src="https://static.vue-js.com/65f89e60-3ac6-11eb-85f6-6fac77c0c9b3.png"></p><p>用<code>vue</code>来实现，我们知道<code>vue</code>基本不操作<code>dom</code>节点， 双向绑定使<code>dom</code>节点跟视图绑定后，通过修改变量的值控制<code>dom</code>节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图</p><p> <img src="https://static.vue-js.com/6f916fb0-3ac6-11eb-ab90-d9ae814b240d.png"></p><p>总结就是：</p><ul><li>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM</li><li>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM</li></ul><h2 id="五、Vue和React对比"><a href="#五、Vue和React对比" class="headerlink" title="五、Vue和React对比"></a>五、Vue和React对比</h2><p>这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同</p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：<code>Vue</code>的<code>weex</code>、<code>React</code>的<code>React native</code></li><li>都有自己的构建工具：<code>Vue</code>的<code>vue-cli</code>、<code>React</code>的<code>Create React App</code></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>数据流向的不同。<code>react</code>从诞生开始就推崇单向数据流，而<code>Vue</code>是双向数据流</li><li>数据变化的实现原理不同。<code>react</code>使用的是不可变数据，而<code>Vue</code>使用的是可变的数据</li><li>组件化通信的不同。<code>react</code>中我们通过使用回调函数来进行通信的，而<code>Vue</code>中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。<code>react</code>主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。<code>Vue</code> 使用双向指针，边对比，边更新DOM</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000016269636">https://segmentfault.com/a/1190000016269636</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Vue.js">https://zh.wikipedia.org/zh-cn/Vue.js</a></li><li><a href="https://zhuanlan.zhihu.com/p/20197803">https://zhuanlan.zhihu.com/p/20197803</a></li><li><a href="https://zhuanlan.zhihu.com/p/38296857">https://zhuanlan.zhihu.com/p/38296857</a></li></ul><p> <img src="https://static.vue-js.com/821b87b0-3ac6-11eb-ab90-d9ae814b240d.png"></p>]]></content>
      
      
      <categories>
          
          <category> 面试相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官：Vue实例挂载的过程</title>
      <link href="/2021/08/24/vue/new-vue/"/>
      <url>/2021/08/24/vue/new-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：Vue实例挂载的过程"><a href="#面试官：Vue实例挂载的过程" class="headerlink" title="面试官：Vue实例挂载的过程"></a>面试官：Vue实例挂载的过程</h1><p><img src="https://static.vue-js.com/63194810-3a09-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h2><p>我们都听过知其然知其所以然这句话</p><p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p><p>过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p><h2 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h2><p>首先找到<code>vue</code>的构造函数</p><p>源码位置：src\core\instance\index.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Vue</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>    <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Vue is a constructor and should be called with the `new` keyword'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p><p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">initMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 定义 _init</span><span class="token function">stateMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义 $set $get $delete $watch 等</span><span class="token function">eventsMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 定义事件  $on  $once $off $emit</span><span class="token function">lifecycleMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定义 _update  $forceUpdate  $destroy</span><span class="token function">renderMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 定义 _render 返回虚拟dom</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p><p>源码位置：src\core\instance\init.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment">// a uid</span>    vm<span class="token punctuation">.</span>_uid <span class="token operator">=</span> uid<span class="token operator">++</span>    <span class="token keyword">let</span> startTag<span class="token punctuation">,</span> endTag    <span class="token comment">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      startTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-start:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>      endTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-end:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_uid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// a flag to avoid this being observed</span>    vm<span class="token punctuation">.</span>_isVue <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment">// merge options</span>    <span class="token comment">// 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// optimize internal component instantiation</span>      <span class="token comment">// since dynamic options merging is pretty slow, and none of the</span>      <span class="token comment">// internal component options needs special treatment.</span>      <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 合并vue属性</span>      vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>        <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>        options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        vm      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">/* istanbul ignore else */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 初始化proxy拦截器</span>      <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm    <span class="token punctuation">}</span>    <span class="token comment">// expose real self</span>    vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm    <span class="token comment">// 初始化组件生命周期标志位</span>    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token comment">// 初始化组件事件侦听</span>    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token comment">// 初始化渲染方法</span>    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>    <span class="token comment">// 初始化依赖注入内容，在初始化data、props之前</span>    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>    <span class="token comment">// 初始化props/data/method/watch/methods</span>    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>    <span class="token comment">/* istanbul ignore if */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token function">formatComponentName</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>vm<span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> init</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 挂载元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仔细阅读上面的代码，我们得到以下结论：</p><ul><li><p>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</p></li><li><p>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</p></li><li><p>挂载方法是调用<code>vm.$mount</code>方法</p></li></ul><p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p><p>源码位置：src\core\instance\state.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 初始化组件的watcher列表</span>  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options  <span class="token comment">// 初始化props</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>  <span class="token comment">// 初始化methods方法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 初始化data  </span>    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initData</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data  <span class="token comment">// 获取到组件上的data</span>  data <span class="token operator">=</span> vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span>    <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>    <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>      <span class="token string">'data functions should return an object:\n'</span> <span class="token operator">+</span>      <span class="token string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class="token punctuation">,</span>      vm    <span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment">// proxy data on instance</span>  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props  <span class="token keyword">const</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods  <span class="token keyword">let</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span>length  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 属性名不能与方法名重复</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">warn</span><span class="token punctuation">(</span>          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Method "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" has already been defined as a data property.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>          vm        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 属性名不能与state名称重复</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The data property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" is already declared as a prop. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Use prop default value instead.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        vm      <span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 验证key值的合法性</span>      <span class="token comment">// 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据</span>      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">// observe data</span>  <span class="token comment">// 响应式监听data是数据的变化</span>  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仔细阅读上面的代码，我们可以得到以下结论：</p><ul><li><p>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></p></li><li><p><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</p></li></ul><p>关于数据响应式在这就不展开详细说明</p><p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p><p>源码位置：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>  <span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>  <span class="token comment">// 获取或查询元素</span>  el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>  <span class="token comment">/* istanbul ignore if */</span>  <span class="token comment">// vue 不允许直接挂载到body或页面文档上</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>el <span class="token operator">===</span> document<span class="token punctuation">.</span>body <span class="token operator">||</span> el <span class="token operator">===</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.</span><span class="token template-punctuation string">`</span></span>    <span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">this</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options  <span class="token comment">// resolve template/el and convert to render function</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> template <span class="token operator">=</span> options<span class="token punctuation">.</span>template    <span class="token comment">// 存在template模板，解析vue模板文件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> template <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          template <span class="token operator">=</span> <span class="token function">idToTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>          <span class="token comment">/* istanbul ignore if */</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">warn</span><span class="token punctuation">(</span>              <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Template element not found or is empty: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>options<span class="token punctuation">.</span>template<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>              <span class="token keyword">this</span>            <span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">.</span>nodeType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        template <span class="token operator">=</span> template<span class="token punctuation">.</span>innerHTML      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'invalid template option:'</span> <span class="token operator">+</span> template<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">this</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 通过选择器获取元素内容</span>      template <span class="token operator">=</span> <span class="token function">getOuterHTML</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* istanbul ignore if */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'compile'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment">/**       *  1.将temmplate解析ast tree       *  2.将ast tree转换成render语法字符串       *  3.生成render方法       */</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> staticRenderFns <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token punctuation">{</span>        outputSourceRange<span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">,</span>        shouldDecodeNewlines<span class="token punctuation">,</span>        shouldDecodeNewlinesForHref<span class="token punctuation">,</span>        delimiters<span class="token operator">:</span> options<span class="token punctuation">.</span>delimiters<span class="token punctuation">,</span>        comments<span class="token operator">:</span> options<span class="token punctuation">.</span>comments      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>      options<span class="token punctuation">.</span>render <span class="token operator">=</span> render      options<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> staticRenderFns      <span class="token comment">/* istanbul ignore if */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'compile end'</span><span class="token punctuation">)</span>        <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> compile</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token string">'compile'</span><span class="token punctuation">,</span> <span class="token string">'compile end'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">mount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阅读上面代码，我们能得到以下结论：</p><ul><li><p>不要将根元素放到<code>body</code>或者<code>html</code>上</p></li><li><p>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</p></li><li><p>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</p></li></ul><p>对<code>template</code>的解析步骤大致分为以下几步：</p><ul><li><p>将<code>html</code>文档片段解析成<code>ast</code>描述符</p></li><li><p>将<code>ast</code>描述符解析成字符串</p></li><li><p>生成<code>render</code>函数</p></li></ul><p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p><p>源码位置：src\platforms\web\runtime\index.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// public mount method</span><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>  <span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>  el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> inBrowser <span class="token operator">?</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">undefined</span>  <span class="token comment">// 渲染组件</span>  <span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>mountComponent</code>渲染组件</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>  <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>  el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el  <span class="token comment">// 如果没有获取解析的render函数，则会抛出警告</span>  <span class="token comment">// render是解析模板文件生成的</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render <span class="token operator">=</span> createEmptyVNode    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* istanbul ignore if */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>template<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token operator">||</span>        vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el <span class="token operator">||</span> el<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">warn</span><span class="token punctuation">(</span>          <span class="token string">'You are using the runtime-only build of Vue where the template '</span> <span class="token operator">+</span>          <span class="token string">'compiler is not available. Either pre-compile the templates into '</span> <span class="token operator">+</span>          <span class="token string">'render functions, or use the compiler-included build.'</span><span class="token punctuation">,</span>          vm        <span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 没有获取到vue的模板文件</span>        <span class="token function">warn</span><span class="token punctuation">(</span>          <span class="token string">'Failed to mount component: template or render function not defined.'</span><span class="token punctuation">,</span>          vm        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">// 执行beforeMount钩子</span>  <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> updateComponent  <span class="token comment">/* istanbul ignore if */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> name <span class="token operator">=</span> vm<span class="token punctuation">.</span>_name      <span class="token keyword">const</span> id <span class="token operator">=</span> vm<span class="token punctuation">.</span>_uid      <span class="token keyword">const</span> startTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-start:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>      <span class="token keyword">const</span> endTag <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-perf-end:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>      <span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>startTag<span class="token punctuation">)</span>      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>      <span class="token function">mark</span><span class="token punctuation">(</span>endTag<span class="token punctuation">)</span>      <span class="token function">measure</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> patch</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> startTag<span class="token punctuation">,</span> endTag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 定义更新函数</span>    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span>      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">// we set this to vm._watcher inside the watcher's constructor</span>  <span class="token comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>  <span class="token comment">// component's mounted hook), which relies on vm._watcher being already defined</span>  <span class="token comment">// 监听当前组件状态，当有数据变化时，更新组件</span>  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 数据更新引发的组件更新</span>        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>  hydrating <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token comment">// manually mounted instance, call mounted on self</span>  <span class="token comment">// mounted is called for render-created child components in its inserted hook</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'mounted'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> vm<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阅读上面代码，我们得到以下结论：</p><ul><li>会触发<code>boforeCreate</code>钩子</li><li>定义<code>updateComponent</code>渲染页面视图的方法</li><li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li></ul><p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p><p><code>render</code>的作用主要是生成<code>vnode</code></p><p>源码位置：src\core\instance\render.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义vue 原型上的render方法</span><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token comment">// render函数来自于组件的option</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options    <span class="token keyword">if</span> <span class="token punctuation">(</span>_parentVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vm<span class="token punctuation">.</span>$scopedSlots <span class="token operator">=</span> <span class="token function">normalizeScopedSlots</span><span class="token punctuation">(</span>            _parentVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>scopedSlots<span class="token punctuation">,</span>            vm<span class="token punctuation">.</span>$slots<span class="token punctuation">,</span>            vm<span class="token punctuation">.</span>$scopedSlots        <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// set parent vnode. this allows render functions to have access</span>    <span class="token comment">// to the data on the placeholder node.</span>    vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> _parentVnode    <span class="token comment">// render self</span>    <span class="token keyword">let</span> vnode    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// There's no need to maintain a stack because all render fns are called</span>        <span class="token comment">// separately from one another. Nested component's render fns are called</span>        <span class="token comment">// when parent component is patched.</span>        currentRenderingInstance <span class="token operator">=</span> vm        <span class="token comment">// 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span>        vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>        <span class="token comment">// return error render result,</span>        <span class="token comment">// or previous vnode to prevent render error causing blank component</span>        <span class="token comment">/* istanbul ignore else */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>renderError<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span><span class="token function">renderError</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">renderError</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>                vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        currentRenderingInstance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">}</span>    <span class="token comment">// if the returned array contains only a single node, allow it</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vnode <span class="token operator">=</span> vnode<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token comment">// return empty vnode in case the render function errored out</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>vnode <span class="token keyword">instanceof</span> <span class="token class-name">VNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">warn</span><span class="token punctuation">(</span>                <span class="token string">'Multiple root nodes returned from render function. Render function '</span> <span class="token operator">+</span>                <span class="token string">'should return a single root node.'</span><span class="token punctuation">,</span>                vm            <span class="token punctuation">)</span>        <span class="token punctuation">}</span>        vnode <span class="token operator">=</span> <span class="token function">createEmptyVNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// set parent</span>    vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode    <span class="token keyword">return</span> vnode<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p><p>源码位置：src\core\instance\lifecycle.js</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el    <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode    <span class="token comment">// 设置当前激活的作用域</span>    <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>    vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode    <span class="token comment">// Vue.prototype.__patch__ is injected in entry points</span>    <span class="token comment">// based on the rendering backend used.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// initial render</span>      <span class="token comment">// 执行具体的挂载逻辑</span>      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment">// updates</span>      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">restoreActiveInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// update __vue__ reference</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>      prevEl<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> vm    <span class="token punctuation">}</span>    <span class="token comment">// if parent is an HOC, update its $el as well</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">===</span> vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el    <span class="token punctuation">}</span>    <span class="token comment">// updated hook is called by the scheduler to ensure that children are</span>    <span class="token comment">// updated in a parent's updated hook.</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><ul><li><p><code>new Vue</code>的时候调用会调用<code>_init</code>方法</p><ul><li>定义 <code>$set</code>、<code> $get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li><li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off </code>等事件</li><li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li></ul></li><li><p>调用<code>$mount</code>进行页面的挂载</p></li><li><p>挂载的时候主要是通过<code>mountComponent</code>方法</p></li><li><p>定义<code>updateComponent</code>更新函数</p></li><li><p>执行<code>render</code>生成虚拟<code>DOM</code></p></li><li><p><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/gerry2019/p/12001661.html">https://www.cnblogs.com/gerry2019/p/12001661.html</a></li><li><a href="https://github.com/vuejs/vue/tree/dev/src/core/instance">https://github.com/vuejs/vue/tree/dev/src/core/instance</a> </li><li><a href="https://vue3js.cn/">https://vue3js.cn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的Linux WiFi CSITool</title>
      <link href="/2021/07/12/cong-ling-kai-shi-de-linux-wifi-csitool/"/>
      <url>/2021/07/12/cong-ling-kai-shi-de-linux-wifi-csitool/</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要参考"><a href="#本文主要参考" class="headerlink" title="本文主要参考"></a>本文主要参考</h1><h3 id="1-官方资料"><a href="#1-官方资料" class="headerlink" title="1.官方资料"></a>1.官方资料</h3><h4 id="1-1-官方Q-amp-A"><a href="#1-1-官方Q-amp-A" class="headerlink" title="1.1 官方Q&amp;A"></a>1.1 官方Q&amp;A</h4><p>链接：<a href="http://dhalperi.github.io/linux-80211n-csitool/faq.html">http://dhalperi.github.io/linux-80211n-csitool/faq.html</a></p><p>点<code>+</code>号看详细信息，重点关注<code>2</code>和<code>13</code></p><h4 id="1-2-官方GitHub"><a href="#1-2-官方GitHub" class="headerlink" title="1.2 官方GitHub"></a>1.2 官方GitHub</h4><p>链接：<a href="https://github.com/dhalperi/linux-80211n-csitool-supplementary/tree/master/injection">https://github.com/dhalperi/linux-80211n-csitool-supplementary/</a></p><h3 id="2-亲测可用安装教程"><a href="#2-亲测可用安装教程" class="headerlink" title="2. 亲测可用安装教程"></a>2. 亲测可用安装教程</h3><h4 id="2-1-灵魂序曲的教程"><a href="#2-1-灵魂序曲的教程" class="headerlink" title="2.1 灵魂序曲的教程"></a>2.1 <strong>灵魂序曲的教程</strong></h4><p>​    虽然有的步骤有些麻烦，但是AP模式亲测可用，monitor模式可能是我驱动没改对，我这里收不到数，但也许教程本身没问题是我的问题。我也没过深究。</p><p>链接： <a href="https://blog.csdn.net/u014645508/article/details/81359409">https://blog.csdn.net/u014645508/article/details/81359409</a></p><h4 id="2-2-沃一德的教程"><a href="#2-2-沃一德的教程" class="headerlink" title="2.2 沃一德的教程"></a>2.2 <strong>沃一德的教程</strong></h4><p>比较精简，但monitor模式博主是亲测可用的。</p><p>链接：<a href="https://blog.csdn.net/qq_20604671/article/details/53996239">https://blog.csdn.net/qq_20604671/article/details/53996239</a></p><h1 id="Linux基础及CSI相关知识的学习"><a href="#Linux基础及CSI相关知识的学习" class="headerlink" title="Linux基础及CSI相关知识的学习"></a>Linux基础及CSI相关知识的学习</h1><h3 id="1-Linux基础"><a href="#1-Linux基础" class="headerlink" title="1. Linux基础"></a>1. Linux基础</h3><h4 id="1-1-视频教程"><a href="#1-1-视频教程" class="headerlink" title="1.1 视频教程"></a>1.1 视频教程</h4><p><strong>兄弟连的linux教程：</strong><a href="https://www.bilibili.com/video/BV1mW411i7Qf">https://www.bilibili.com/video/BV1mW411i7Qf</a><br>看P1-P26左右基本就可以了，看视频虽然更容易理解，但是效率比较低，而且很容易犯困。</p><h4 id="1-2-文字教程"><a href="#1-2-文字教程" class="headerlink" title="1.2 文字教程"></a>1.2 文字教程</h4><p><strong>Cyc的文字教程：</strong><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/Linux.html#%E5%89%8D%E8%A8%80">http://www.cyc2018.xyz/</a><br>无论是什么教程核心，最重要的就是自己敲一遍，看看效果，加深印象！！！！</p><h3 id="2-CSI相关"><a href="#2-CSI相关" class="headerlink" title="2. CSI相关"></a>2. CSI相关</h3><h4 id="2-1-802-11n协议"><a href="#2-1-802-11n协议" class="headerlink" title="2.1 802.11n协议"></a>2.1 802.11n协议</h4><p><strong>IEEE 802.11n协议：</strong><a href="https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=5307322&amp;ref=aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2RvY3VtZW50LzUzMDczMjI=">https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=5307322</a></p><p>对802.11协议以及802.11n协议有一些初步了解，重点是<code>7-25</code>。</p><h4 id="2-2-CSI简介"><a href="#2-2-CSI简介" class="headerlink" title="2.2 CSI简介"></a>2.2 CSI简介</h4><p>Wi-Fi CSI的那些事：<br><a href="https://blog.csdn.net/nku_zhaolinsheng/article/details/75210563">https://blog.csdn.net/nku_zhaolinsheng/article/details/75210563</a><br>通过读paper已经对CSI肯定有一些了解了，但是这里重点是第一部分，从OSI模型的角度去看获取CSI的原理。</p><h1 id="一、Ubuntu安装"><a href="#一、Ubuntu安装" class="headerlink" title="一、Ubuntu安装"></a>一、Ubuntu安装</h1><p>​    如果我们想要收集CSI数据，首先就需要安装符合要求的操作系统，根据CSI_Tool官方文档，需要安装的系统内核版本要在<code>3.2~4.2</code>之间。</p><p>​    此次我们安装的操作系统为<code>ubuntu-14.04.1</code>，系统内核版本为<code>3.13</code>。</p><p>​    系统下载地址为：<a href="https://pan.baidu.com/s/1eTu0OP8Jb1TwGJFkBZnr1w">https://pan.baidu.com/s/1eTu0OP8Jb1TwGJFkBZnr1w</a> 提取码：oi6x</p><p>​    具体的安装方法自行百度，在此不在赘述。</p><h1 id="二、CSI-Tool安装"><a href="#二、CSI-Tool安装" class="headerlink" title="二、CSI Tool安装"></a>二、CSI Tool安装</h1><p>安装好ubantu系统之后（系统版本和内核版本符合要求），接下来的就是安装<code>CSI_Tools</code>，如果你是按照上面的步骤来进行安装系统，那么接下来就不用有任何的顾虑，直接<code>无脑执行 </code>下面的命令就可以，一个一个的执行，有时候会有一些提示也不要管，那不是错误，总之闭着眼睛执行就行了，大家对比官方的可能觉得我的怎么这么少，因为官方安有很多是为了提示信息啥的，对用功能的实现没有影响，为了简单我都直接跳过了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install gcc make linux-headers-$(uname -r) git-core<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">CSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面一步是去GitHub下载CSI Tool，推荐直接网盘下载。直接在GitHub下载实在是太慢了（毕竟1个多G）！！！</p><p>百度网盘链接：链接: <a href="https://pan.baidu.com/s/15vt73N0PQeJkyvSjSgAU4Q">https://pan.baidu.com/s/15vt73N0PQeJkyvSjSgAU4Q</a> 提取码: bq94 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https://github.com/dhalperi/linux-80211n-csitool.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载之后进行解压</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf /linux-80211n-csitool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进入文件夹</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd linux-80211n-csitool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git checkout ${CSITOOL_KERNEL_TAG}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这一步make编译的时候，会提示<code> Can’t read private key</code>，不必理会，官方也说了没事，可以參考以下官方文档：<a href="https://dhalperi.github.io/linux-80211n-csitool/installation.html%E3%80%82">https://dhalperi.github.io/linux-80211n-csitool/installation.html。</a></p><p>遇到这个问题可以参考：<a href="https://blog.csdn.net/zhangpeterx/article/details/88044404">https://blog.csdn.net/zhangpeterx/article/details/88044404</a></p><p>到此为止环境配置完毕。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="三、AP模式收数"><a href="#三、AP模式收数" class="headerlink" title="三、AP模式收数"></a>三、AP模式收数</h1><h4 id="1-配置MAC"><a href="#1-配置MAC" class="headerlink" title="1.配置MAC"></a>1.配置MAC</h4><p>要求路由器无密码，因为CSI Tool的固件没有足够的代码空间来存储波束成形软件路径（用于测量CSI）和加密软件路径（用于WEP / WPA / WPA2 /等网络）。</p><p>若未修改驱动，需要输入，否则可以跳过</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo modprobe -r iwlwifi mac80211<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步执行之后就已经搜不到无线网了。</p><h4 id="2-配置连接属性"><a href="#2-配置连接属性" class="headerlink" title="2.配置连接属性"></a>2.配置连接属性</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo modprobe iwlwifi connector_log=0x1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步执行之后可以搜到无线网，但是无论是有无密码的都连不上。</p><h4 id="3-配置连接无线网"><a href="#3-配置连接无线网" class="headerlink" title="3.配置连接无线网"></a>3.配置连接无线网</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo killall wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>现在可以连接上不加密的无线网了</code>。</p><h4 id="4-启动工具"><a href="#4-启动工具" class="headerlink" title="4.启动工具"></a>4.启动工具</h4><p>执行下面的命令开始记录数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>csi.dat</code> 是文件名，可任意，他会出现在你的用户目录下，就是你安装这个工具的同级文件夹下。</p><h3 id="5-ping-路由器"><a href="#5-ping-路由器" class="headerlink" title="5.ping 路由器"></a>5.ping 路由器</h3><p>另开一个终端，执行下面的命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo ping 101.6.69.105 -i 0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>101.6.69.105是路由的ip地址，-i 0.2表示发送间隔0.2s，<code>如果间隔小于0.5s需要加上sudo</code>。</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSI数据格式</title>
      <link href="/2021/07/08/csi-shu-ju-ge-shi/"/>
      <url>/2021/07/08/csi-shu-ju-ge-shi/</url>
      
        <content type="html"><![CDATA[<p>数据采集工具csi_tool采集数据并保存为后缀.dat的数据文件，在csi_tool中提供一个c语言函数解析此文件。阅读了c语言的解析代码后发现，数据文件的组织方法与计网中数据十分相似，但略有不同。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>总体上，整个文件仅由n个bfee组成，巧了，数据文件中应当包含有n个采样信息，这个bfee的意义不言而喻，就是和采样一一对应。</p><p>bfee： <a href="https://camo.githubusercontent.com/43b5ba5d76e0c3868f4a7dd393cdd0e0c77d948ff25e1c27f2935a38219647df/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039323934363736382e706e67"><img src="https://camo.githubusercontent.com/43b5ba5d76e0c3868f4a7dd393cdd0e0c77d948ff25e1c27f2935a38219647df/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039323934363736382e706e67"></a></p><p>bfee的数据结构如上图所示。</p><p>前<strong>两字节是field_len</strong>，之后<strong>一字节是code</strong>，再之后便是可变长度的field。<strong>field_len等于code+field的字长</strong>。<br><strong>当code为187时，表示field中是信道信息；</strong></p><p>不是187时，表示field中是其他信息。<br>我们关心的是信道信息，其他信息不解析，跳过该bfee即可。</p><p>field： <a href="https://camo.githubusercontent.com/26e98191e2cd37de9d76d6ecb621ab6f3373f39180ac5d5b9d389e8739874bd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333030393936362e706e67"><img src="https://camo.githubusercontent.com/26e98191e2cd37de9d76d6ecb621ab6f3373f39180ac5d5b9d389e8739874bd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333030393936362e706e67"></a></p><p>若code等于187，field有如上图数据格式。</p><p>到这里你一定感觉很熟悉了。 field分为<strong>头部和有效载荷(payload)<strong>两部分。</strong>头部有20字节</strong>的固定长度，有效载荷是个可变长度，字长为len。</p><p>头部各字段的数据类型和意义如下表：</p><p><a href="https://camo.githubusercontent.com/7c6a93df785699ae494adafbad81e568fbfb249b45daf699e415f6d72875e33e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333032373636372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c316c31595735456157467554773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/7c6a93df785699ae494adafbad81e568fbfb249b45daf699e415f6d72875e33e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333032373636372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c316c31595735456157467554773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730"></a></p><p>可以见得，头部中包含了主要的信道信息。</p><p>而其中最重要的<strong>csi矩阵</strong>，分为<strong>30个subc</strong>，保存在<strong>有效载荷</strong>中。分别对应30个子载波。</p><p><strong>subc</strong>的结构如下表所示：</p><p><a href="https://camo.githubusercontent.com/3cc70eec74a7495b549fd2c7978143b2805676883a5f3dd03fe0ee7c25e64fa2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333035373536302e706e67"><img src="https://camo.githubusercontent.com/3cc70eec74a7495b549fd2c7978143b2805676883a5f3dd03fe0ee7c25e64fa2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333035373536302e706e67"></a></p><p><strong>复数</strong>的结构：</p><p><a href="https://camo.githubusercontent.com/68694dc0248c9eec743b54e1ba8aa9ffbc3821a34e580c1eb3211543a4a715c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333131343731392e706e67"><img src="https://camo.githubusercontent.com/68694dc0248c9eec743b54e1ba8aa9ffbc3821a34e580c1eb3211543a4a715c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303832313039333131343731392e706e67"></a></p><p><strong>每个subc的开始会有3位的非数据部分</strong>，因此subc的长度不是字节(8位)的整数倍，这将导致subc这部分的解析需要按比特操作，增加我解析工作的复杂度。</p><p>到这里，整个文件的数据结构都清楚了，开始试着用python来解析run-lxx.dat这个文件。</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI数据格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSI安装方法</title>
      <link href="/2021/06/17/csi-an-zhuang/"/>
      <url>/2021/06/17/csi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第一种安装方法"><a href="#一、第一种安装方法" class="headerlink" title="一、第一种安装方法"></a>一、第一种安装方法</h1><h2 id="1-操作系统和硬件配置"><a href="#1-操作系统和硬件配置" class="headerlink" title="1. 操作系统和硬件配置"></a>1. 操作系统和硬件配置</h2><ul><li><h5 id="操作系统：-ubuntu-14-04-3-amd64"><a href="#操作系统：-ubuntu-14-04-3-amd64" class="headerlink" title="操作系统： ubuntu-14.04.3 (amd64)"></a>操作系统： ubuntu-14.04.3 (amd64)</h5><ul><li>系统镜像下载地址： 百度网盘</li></ul><p> 链接：<a href="https://pan.baidu.com/s/1lkI73gSumcvDdBsdB3vyfg">https://pan.baidu.com/s/1lkI73gSumcvDdBsdB3vyfg</a> 提取码：1895</p><ul><li>重装系统方法可参考：<a href="https://blog.csdn.net/weixin_43226231/article/details/100692676">https://blog.csdn.net/weixin_43226231/article/details/100692676</a></li></ul></li><li><h5 id="更换下载源：-最好更换为国内源，推荐阿里源，换源方法可参考：https-blog-csdn-net-qq-35451572-article-details-79516563-biz-id-102-amp-utm-term-ubuntu-E5-9B-BD-E5-86-85-E6-BA-90-amp-utm-medium-distribute-pc-search-result-none-task-blog-2allsobaiduweb-default-0-79516563-amp-spm-1018-2118-3001-4187"><a href="#更换下载源：-最好更换为国内源，推荐阿里源，换源方法可参考：https-blog-csdn-net-qq-35451572-article-details-79516563-biz-id-102-amp-utm-term-ubuntu-E5-9B-BD-E5-86-85-E6-BA-90-amp-utm-medium-distribute-pc-search-result-none-task-blog-2allsobaiduweb-default-0-79516563-amp-spm-1018-2118-3001-4187" class="headerlink" title="更换下载源： 最好更换为国内源，推荐阿里源，换源方法可参考：https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187"></a>更换下载源： 最好更换为国内源，推荐阿里源，换源方法可参考：<a href="https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/qq_35451572/article/details/79516563?biz_id=102&amp;utm_term=ubuntu%E5%9B%BD%E5%86%85%E6%BA%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-79516563&amp;spm=1018.2118.3001.4187</a></h5></li></ul><h2 id="2-准备工作——发射器接收器都需要的操作"><a href="#2-准备工作——发射器接收器都需要的操作" class="headerlink" title="2. 准备工作——发射器接收器都需要的操作"></a>2. 准备工作——发射器接收器都需要的操作</h2><ul><li><h5 id="在terminal输入以下指令："><a href="#在terminal输入以下指令：" class="headerlink" title="在terminal输入以下指令："></a>在terminal输入以下指令：</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install gcc make linux-headers-$(uname -r) git-coreCSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><h5 id="下载CSITOOL"><a href="#下载CSITOOL" class="headerlink" title="下载CSITOOL"></a>下载CSITOOL</h5><ul><li><p>官方链接：（不推荐）</p><p>git clone <a href="https://github.com/dhalperi/linux-80211n-csitool.git">https://github.com/dhalperi/linux-80211n-csitool.git</a></p></li><li><p>推荐下载链接：百度网盘</p><p>链接：<a href="https://pan.baidu.com/s/1JTfz-wAPU5WLyA_gHynK_Q">https://pan.baidu.com/s/1JTfz-wAPU5WLyA_gHynK_Q</a> 提取码：1895</p></li></ul></li><li><h5 id="接下来执行："><a href="#接下来执行：" class="headerlink" title="接下来执行："></a>接下来执行：</h5><pre class="line-numbers language-none"><code class="language-none">cd linux-80211n-csitoolgit checkout ${CSITOOL_KERNEL_TAG}make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modulessudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo depmodcd ..git clone https://github.com/dhalperi/linux-80211n-csitool-supplementary.gitfor file in /lib/firmware/iwlwifi-5000-*.ucode; do sudo mv $file $file.orig; donesudo cp linux-80211n-csitool-supplementary/firmware/iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/    sudo ln -s iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/iwlwifi-5000-2.ucodemake -C linux-80211n-csitool-supplementary/netlink```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><em>若直接用AP模式的话可执行以下指令：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo modprobe -r iwlwifi mac80211sudo modprobe iwlwifi connector_log=0x1sudo killall wpa_supplicant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><em>然后链接上没有密码的路由器，执行：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>打开一个新的终端执行：</em></p><pre class="line-numbers language-none"><code class="language-none">sudo ping 192.168.1.1 -i 0.005<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>这样AP模式就可以开始接收数据了</em></p></li></ul></li><li><h5 id="下载lorcon"><a href="#下载lorcon" class="headerlink" title="下载lorcon:"></a>下载lorcon:</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install libpcap-devgit clone https://github.com/dhalperi/lorcon-old.gitcd lorcon-old./configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-配置Monitor模式"><a href="#3-配置Monitor模式" class="headerlink" title="3. 配置Monitor模式"></a>3. 配置Monitor模式</h2><ul><li><h5 id="将发射器的-linux-80211n-csitool-supplementary-injection目录下的setup-inject-sh-改为以下代码："><a href="#将发射器的-linux-80211n-csitool-supplementary-injection目录下的setup-inject-sh-改为以下代码：" class="headerlink" title="将发射器的**/linux-80211n-csitool-supplementary/injection目录下的setup_inject.sh**改为以下代码："></a>将发射器的**/linux-80211n-csitool-supplementary/injection<strong>目录下的</strong>setup_inject.sh**改为以下代码：</h5><p><em><strong>(以下脚本可自行按需更改)</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/sudo /bin/bashrfkill unblock allmodprobe -r iwlwifi mac80211 cfg80211modprobe iwlwifi debug=0x40000ifconfig wlan0 2&gt;/dev/null 1&gt;/dev/nullwhile [ $? -ne 0 ]do        ifconfig wlan0 2&gt;/dev/null 1&gt;/dev/nulldoneiw dev wlan0 interface add mon0 type monitorsudo ifconfig wlan0 downsudo ifconfig mon0 upiw mon0 set channel $1 $2ifconfig mon0 upsudo chmod 777 /sys/kernel/debug/sudo chmod 777 /sys/kernel/debug/tracing/echo 0x4101 | sudo tee `find /sys -name monitor_tx_rate`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="将接收器的-linux-80211n-csitool-supplementary-injection目录下的setup-monitor-csi-sh-改为以下代码"><a href="#将接收器的-linux-80211n-csitool-supplementary-injection目录下的setup-monitor-csi-sh-改为以下代码" class="headerlink" title="将接收器的**/linux-80211n-csitool-supplementary/injection目录下的setup_monitor_csi.sh**改为以下代码"></a>将接收器的**/linux-80211n-csitool-supplementary/injection<strong>目录下的</strong>setup_monitor_csi.sh**改为以下代码</h5><p><em><strong>(以下脚本可自行按需更改)</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/sudo /bin/bashmodprobe -r iwlwifi mac80211 cfg80211modprobe iwlwifi connector_log=0x1# Setup monitor mode, loop until it worksiwconfig wlan0 mode monitor 2&gt;/dev/null 1&gt;/dev/nullwhile [ $? -ne 0 ]doiwconfig wlan0 mode monitor 2&gt;/dev/null 1&gt;/dev/nulldoneecho "1234444"ifconfig wlan0 upiw wlan0 set channel $1 $2ifconfig wlan0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="在两台机子上都执行以下命令："><a href="#在两台机子上都执行以下命令：" class="headerlink" title="在两台机子上都执行以下命令："></a>在两台机子上都执行以下命令：</h5><pre class="line-numbers language-none"><code class="language-none">cd ~cd linux-80211n-csitool-supplementary/injectionmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="4-启动Monitor模式"><a href="#4-启动Monitor模式" class="headerlink" title="4. 启动Monitor模式"></a>4. 启动Monitor模式</h2><p>在/linux-80211n-csitool-supplementary/injection下执行以下步骤，即先cd /linux-80211n-csitool-supplementary/injection</p><p>发射端：</p><pre class="line-numbers language-none"><code class="language-none"> ./setup_inject.sh 64 HT20sudo ./random_packets 10000 100 1 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接收端</p><pre class="line-numbers language-none"><code class="language-none">./setup_monitor_csi.sh 64 HT20sudo ../netlink/log_to_file log.dat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>如果发射端在重启之后正常启动，但是接收端没有接收到数据的话，就把发射器机子上的/linux-80211n-csitool-supplementary/injection文件夹下的.o文件删掉，然后在该目录下重新make就可以了。</em></p><p>参考文章：<a href="https://blog.csdn.net/bixianren9179/article/details/103802974">https://blog.csdn.net/bixianren9179/article/details/103802974</a></p><p> <a href="https://blog.csdn.net/dfcaihg/article/details/83552072">https://blog.csdn.net/dfcaihg/article/details/83552072</a></p><h1 id="二、另一种安装方法"><a href="#二、另一种安装方法" class="headerlink" title="二、另一种安装方法"></a>二、另一种安装方法</h1><p>用的是第一种方法提供的系统安装镜像文件。</p><p>如果你的硬件和系统都和我的一样，那么接下来就不用有任何顾虑了，直接 无脑执行 下面的命令就可以，一个一个的执行，有时候会有一些提示也不要管，那不是错误，总之闭着眼睛执行就行了，大家对比官方的可能觉得我的怎么这么少，因为官方安有很多是为了提示信息啥的，对用功能的实现没有影响，为了简单我都直接跳过了：</p><pre class="line-numbers language-none"><code class="language-none">1、sudo apt-get install gcc make linux-headers-$(uname -r) git-core2、CSITOOL_KERNEL_TAG=csitool-$(uname -r | cut -d . -f 1-2)3、git clone https://github.com/dhalperi/linux-80211n-csitool.git4、cd linux-80211n-csitool5、git checkout ${CSITOOL_KERNEL_TAG}6、make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi modules7、sudo make -C /lib/modules/$(uname -r)/build M=$(pwd)/drivers/net/wireless/iwlwifi INSTALL_MOD_DIR=updates modules_install8、sudo depmod9、cd ..10、git clone https://github.com/dhalperi/linux-80211n-csitool-supplementary.git11、for file in /lib/firmware/iwlwifi-5000-*.ucode; do sudo mv $file $file.orig; done12、sudo cp linux-80211n-csitool-supplementary/firmware/iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/13、sudo ln -s iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/iwlwifi-5000-2.ucode14、make -C linux-80211n-csitool-supplementary/netlink`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中间第三步下载的速度是比较慢的，毕竟是从 github 上面下载 1个多 G 的文件，我原本以为速度很慢，但其实还好，1个小时左右就可以搞定。</p><p>然后在<strong>第7步</strong> make 编译的时候会有提示 <strong>Can’t read private key</strong> ，不要理会，官方也说了没事：<a href="https://dhalperi.github.io/linux-80211n-csitool/installation.html">https://dhalperi.github.io/linux-80211n-csitool/installation.html</a></p><p>遇到这个问题可以参考：<a href="https://blog.csdn.net/zhangpeterx/article/details/88044404">https://blog.csdn.net/zhangpeterx/article/details/88044404</a></p><p>到此为止环境配置完毕。</p><p><strong>1、配置 mac</strong><br><code>sudo modprobe -r iwlwifi mac80211</code><br>这一步执行之后已经搜不到无线网了。</p><p><strong>2、配置连接属性</strong><br><code>sudo modprobe iwlwifi connector_log=0x1</code><br>这一步执行之后可以搜到，但是无论是有无密码的都连不上。</p><p><strong>3、配置连接无线网</strong><br><code>sudo killall wpa_supplicant</code><br>现在可以<strong>连接上不加密的无线网</strong>了。</p><p><strong>4、启动工具</strong><br>执行下面的命令开始记录数据：<code>sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat</code><br>其中 csi.dat 是文件名，可任意，他会出现在你的用户目录下，就是你安装这个工具的同级文件夹下。</p><p><strong>5、ping</strong><br>另开一个终端，执行 <code>ping 192.168.1.1 -i 0.2</code>，其中ip地址是你的路由器网关。</p><p>如果有下图所示的输出就代表成功了。</p><p><img src="/2021/06/17/csi-an-zhuang/Users\Libra\AppData\Roaming\Typora\typora-user-images\image-20210615212010088.png" alt="image-20210615212010088"></p><p><strong>每次启动时的初始化</strong><br>另外每次关机之后就回到了解放前，只需要依次执行下面的命令即可：</p><p><code>sudo modprobe -r iwlwifi mac80211</code></p><p><code>sudo modprobe iwlwifi connector_log=0x1</code></p><p><code>sudo killall wpa_supplicant</code></p><p>你可以把上面的三条命令写成一个脚本，然后再做一个定时任务，每次电脑启动时自动执行就很方便了，我就是这么做的。</p><p>之后点击 wifi 连接你的路由器，最后执行：</p><p><code>sudo linux-80211n-csitool-supplementary/netlink/log_to_file csi.dat</code></p><p>其中 csi.dat 是你要保存的文件名，在用户目录下。</p><p>这个时候他就开始监听了，你直接 ping 路由器就可以获取数据了。</p><p><strong>总结</strong></p><p>我是最近才做的 （2020年5月28日），根据网上 某个亲测可用的教程 👆 做的，不过那个教程确实写得太麻烦了，于是我为了避免别人踩坑，总结了一下做法，希望对大家有帮助，如果你遇到困难或者问题可以在下方留言，我会在一天之内回复。</p><p>另外可视化的操作看这里：</p><p><a href="https://blog.csdn.net/u014645508/article/details/82887470">https://blog.csdn.net/u014645508/article/details/82887470</a><br>————————————————</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSI_Tools安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session，sessionStorage，localStorage的解释以及区别</title>
      <link href="/2021/05/20/session-localstorage-sessionstorage-de-qu-bie/"/>
      <url>/2021/05/20/session-localstorage-sessionstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Web-Storage介绍"><a href="#一、Web-Storage介绍" class="headerlink" title="一、Web Storage介绍"></a>一、Web Storage介绍</h3><p>HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，<code>Web Storage存储机制</code>是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。</p><p>​        我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据<code>存在以下几个问题</code>：</p><ol><li><p>大小：cookie的大小被限制在4KB。</p></li><li><p>带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。</p></li><li><p>复杂性：要正确的操纵cookie是很困难的。</p></li></ol><p>针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是<code>Web Storage</code>。</p><h3 id="二、sessionStorage-和-localStorage"><a href="#二、sessionStorage-和-localStorage" class="headerlink" title="二、sessionStorage 和 localStorage"></a>二、sessionStorage 和 localStorage</h3><p>具体来说，Web Storage又分为两种：<code>sessionStorage</code> 和 <code>localStorage</code>。</p><p>​    （1）localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p><p>​    （2）sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。</p><p>​    这两者的区别在于：<strong>sessionStorage为临时保存，而localStorage为永久保存</strong>。</p><p>​    到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。</p><h3 id="三、sessionStorage和localStorage的使用："><a href="#三、sessionStorage和localStorage的使用：" class="headerlink" title="三、sessionStorage和localStorage的使用："></a>三、sessionStorage和localStorage的使用：</h3><p>（1）创建一个本地存储的<code>键值对</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名和键值作为参数，将会把键值添加到存储中，如果键名存在，则会更新其对应的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）获取数据，将键值传入，即可获取到对应的value值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> sessiondata <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> localdata <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名作为参数，返回键名对应的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）删除单个数据，根据键值移除对应的信息。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该方法接受一个键名作为参数，并把该键名从存储中删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）删除所有的数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//调用该方法会清空存储中的所有键名。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ol><li><p>Cookie，sessionStorage，localStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的<strong>键值对</strong>！</p></li><li><p>sessionStorage和session不是一个概念！！！</p><p>在<strong>服务端</strong>有一种存储方式叫做：session会话存储，常常简称session。</p><p>sessionStorage和localStorage都是浏览器本地存储，统称为Web 存储，存储内容的大小一般支持5-10MB，浏览器通过<code>window.sessionStorage</code> 和 <code>window.localStorage</code>属性来实现本地存储机制。</p><p><strong>说明：</strong></p><ul><li><p>sessionStorage存储的内容会随着浏览器窗口的关闭而消失。</p></li><li><p>localStorage存储的内容，需要手动清除才会消失。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> localStorage </tag>
            
            <tag> sessionStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS和BFS的使用</title>
      <link href="/2021/05/17/dfs-he-bfs-de-shi-yong/"/>
      <url>/2021/05/17/dfs-he-bfs-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>DFS（深度优先搜索）</strong>和 <strong>BFS（广度优先搜索）</strong>就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。</p><p>本文包括以下内容：</p><ul><li><p>DFS 与 BFS 的特点比较</p></li><li><p>BFS 的适用场景</p></li><li><p>如何用 BFS 进行层序遍历</p></li><li><p>如何用 BFS 求解最短路径问题</p></li></ul><h4 id="DFS-与-BFS"><a href="#DFS-与-BFS" class="headerlink" title="DFS 与 BFS"></a><strong>DFS 与 BFS</strong></h4><p>让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用<strong>递归</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BFS 遍历使用<strong>队列</strong>数据结构：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列从头出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 <strong>栈</strong>，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><p>虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/1.gif" style="zoom:80%"><p>这个遍历顺序也是 BFS 能够用来解<code>「层序遍历」</code>、<code>「最短路径」</code>问题的根本原因。下面，我们结合几道例题来讲讲 BFS 是如何求解层序遍历和最短路径问题的。</p><h4 id="BFS-的应用一：层序遍历"><a href="#BFS-的应用一：层序遍历" class="headerlink" title="BFS 的应用一：层序遍历"></a>BFS 的应用一：层序遍历</h4><p>BFS 的层序遍历应用就是本题了：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal 二叉树的层序遍历（Medium）</a></p><blockquote><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p></blockquote><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/2.png" style="zoom:60%"><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。<strong>层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层</strong>。</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/3.png" style="zoom:60%"><p>那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/4.gif" style="zoom:80%"><p>截取 BFS 遍历过程中的某个时刻：</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/5.png" style="zoom:80%"><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 <code>n</code>（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</p><p>这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/6.gif" style="zoom:80%"><p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><p><strong>最终我们得到的题解代码为：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> queue<span class="token punctuation">.</span>length    <span class="token keyword">let</span> level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      level<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a><strong>BFS 的应用二：最短路径</strong></h4><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为<strong>最短路径问题</strong>。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><img src="/2021/05/17/dfs-he-bfs-de-shi-yong/7.png" style="zoom:80%"><blockquote><p>Tips：</p><p>很多同学一看到「最短路径」，就条件反射地想到「Dijkstra 算法」。为什么 BFS 遍历也能找到最短路径呢？</p><p>这是因为，Dijkstra 算法解决的是带权最短路径问题，而我们这里关注的是无权最短路径问题。也可以看成每条边的权重都是 1。这样的最短路径问题，用 BFS 求解就行了。</p><p>在面试中，你可能更希望写 BFS 而不是 Dijkstra。毕竟，敢保证自己能写对 Dijkstra 算法的人不多。</p></blockquote><p>最短路径问题属于图算法。由于图的表示和描述比较复杂，本文用比较简单的网格结构代替。网格结构是一种特殊的图，它的表示和遍历都比较简单，适合作为练习题。在 LeetCode 中，最短路径问题也以网格结构为主。</p><p><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">LeetCode 1162. As Far from Land as Possible</a> 离开陆地的最远距离（Medium）</p><blockquote><p>你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果网格上只有陆地或者海洋，请返回 -1。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到，「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。</p><p>BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORM介绍</title>
      <link href="/2021/05/16/orm-jie-shao/"/>
      <url>/2021/05/16/orm-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ORM介绍"><a href="#一、ORM介绍" class="headerlink" title="一、ORM介绍"></a>一、ORM介绍</h2><h3 id="1-什么是ORM"><a href="#1-什么是ORM" class="headerlink" title="1. 什么是ORM"></a>1. 什么是ORM</h3><ul><li><strong><code>ORM</code></strong> 全拼<code>Object-Relation Mapping</code>.</li><li>中文意为 <strong><code>对象-关系映射</code></strong>.</li><li>在<code>MVC</code>/<code>MVT</code>设计模式中的<code>Model</code>模块中都包括<code>ORM</code></li></ul><h3 id="2-ORM优势"><a href="#2-ORM优势" class="headerlink" title="2.ORM优势"></a>2.ORM优势</h3><p>（1）只需要面向对象编程, 不需要面向数据库编写代码。</p><ul><li>对数据库的操作都转化成对类属性和方法的操作。</li><li>不用编写各种数据库的sql语句。</li></ul><p>（2）实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异。</p><ul><li>不再关注用的是mysql、oracle…等。</li><li>通过简单的配置就可以轻松更换数据库, 而不需要修改代码。</li></ul><h3 id="3-ORM劣势"><a href="#3-ORM劣势" class="headerlink" title="3.ORM劣势"></a>3.ORM劣势</h3><p>（1）相比较直接使用SQL语句操作数据库，有性能损失。</p><p>（2）根据对象的操作转换成SQL语句，根据查询的结果转化为对象，在映射过程中有性能损失。</p><h3 id="4-ORM和数据库关系："><a href="#4-ORM和数据库关系：" class="headerlink" title="4.ORM和数据库关系："></a>4.ORM和数据库关系：</h3><p>在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表.</p><p>基本情况：</p><p>每个模型都是一个Python类，它是<code>django.db.models.Model</code>的子类。模型的每个属性都代表一个数据库字段。</p><p>综上所述，Django为您提供了一个自动生成的数据库访问API。</p><img src="/2021/05/16/orm-jie-shao/ORM.png" alt="ORM和数据库对应关系" style="zoom:80%;"><h2 id="二、ORM用法"><a href="#二、ORM用法" class="headerlink" title="二、ORM用法"></a>二、ORM用法</h2><h3 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h3><p>**<code>属性名 = models.字段类型,</code>**定义属性时需要指定字段类型, 通过字段类型的参数指定选项</p><p>属性名</p><ul><li>不允许使用python的保留关键字</li><li>不允许使用mysql的保留关键字</li><li>不允许使用连续的下划线，因为Django的查询语法就是连续的下划线</li></ul><p><code>AutoField</code>：自动增长的<code>IntegerField</code>, 不指定时Django会自动创建属性名为id的自动增长属性</p><p><code>BooleanField</code>：布尔字段，值为True或False</p><p><code>NullBooleanField</code>：支持Null、True、False三种值</p><p><code>CharField(max_length=20)</code>：字符串</p><ul><li>参数max_length表示最大字符个数</li></ul><p><code>TextFiled</code>：大文本字段，一般超过4000个字符时使用</p><p><code>IntegerField</code>：整数</p><p><code>DecimalField(max_digits=None, decimal_places=None)</code>：可以指定精度的十进制浮点数</p><ul><li>参数max_digits表示总位数</li><li>参数decimal_places表示小数位数</li></ul><p><code>FloatField()</code>：浮点数 </p><p><code>DateField[auto_now=False, auto_now_add=False])</code>：日期</p><ul><li>参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为false</li><li>参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false</li><li>参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</li></ul><p><code>TimeField</code>：参数和DateField一样</p><p><code>DateTimeField</code>：日期时间，参数同DateField</p><p><code> FileField</code>：上传文件字段，以二进制的形式</p><p> <code>ImageField</code>：继承于FileField，对上传的内容进行校验，确保是有效的图片</p><h3 id="2-字段选项："><a href="#2-字段选项：" class="headerlink" title="2.字段选项："></a>2.字段选项：</h3><p><code>null</code>：如果为True，表示允许为空，默认值是False</p><p><code>blank</code>：如果为True，则该字段允许为空白，默认值是False    </p><ul><li>对比：null是数据库范畴的概念，blank是表单验证范畴的</li></ul><p><code>db_column</code>：字段的名称，如果未指定，则使用属性的名称（只限于数据库表中的名字，操作数据库还是类属性的名字）</p><p><code>db_index</code>：若值为True, 则在表中会为此字段创建索引，默认值是False（为了优化查询速度 ）</p><p><code>default</code>：默认值，这可以是值或可调用对象。如果可调用，则每次创建新对象时都会调用它。</p><p><code>primary_key</code>：若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</p><p><code>unique</code>：如果为True, 这个字段在表中必须有唯一值，这个值不能重复，默认值是False</p><p>关系型字段类型:关联表中使用</p><p><strong>注意：Django会自动为表创建主键字段</strong></p><ul><li>如果使用选项设置某属性为主键字段后，Django不会再创建自动增长的主键字段</li><li>默认创建的主键字段为<code>id</code>，可以使用<code>pk</code>代替，pk全拼为<code>primary key</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#人物姓名</span>    gender <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#人物性别</span>    description <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#人物描述</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>    book <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>BookInfo<span class="token punctuation">)</span> <span class="token comment"># 外键约束，人物属于哪本书</span>    pub_date <span class="token operator">=</span> models<span class="token punctuation">.</span>DateField<span class="token punctuation">(</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#日期</span>    readcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#阅读量</span>    commentcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#评论量</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>     <span class="token comment"># 元类信息 : 修改表名</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        db_table <span class="token operator">=</span> <span class="token string">'people_info'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-关系字段类型"><a href="#3-关系字段类型" class="headerlink" title="3.关系字段类型"></a>3.关系字段类型</h3><ul><li>关系型数据库的关系包括三种类型：<ul><li>ForeignKey：一对多，将字段定义在多的一端中</li><li>ManyToManyField：多对多，将字段定义在任意一端中</li><li>OneToOneField：一对一，将字段定义在任意一端中</li></ul></li><li>可以维护递归的关联关系，使用<code>self</code>指定</li></ul><h3 id="4-元选项"><a href="#4-元选项" class="headerlink" title="4.元选项"></a>4.元选项</h3><p><strong>作用</strong>：修改数据库表的默认的名称</p><p>数据库表的默认名称为 :</p><pre class="line-numbers language-none"><code class="language-none">应用名_模型名例：Book应用中定义BookInfo模型类Book_bookinfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在模型类中定义<code>元类Meta</code>，用于设置元信息，使用<code>db_table</code>自定义表的名字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 书籍信息模型</span><span class="token keyword">class</span> <span class="token class-name">BookInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#图书名称</span>     <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span> <span class="token comment">#元信息类</span>        db_table <span class="token operator">=</span> <span class="token string">'bookinfo'</span> <span class="token comment">#自定义表的名字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-模型成员"><a href="#5-模型成员" class="headerlink" title="5.模型成员"></a>5.模型成员</h3><p><strong><code>objects</code> : 管理器对象</strong></p><ul><li>是**<code>Manager</code><strong>类型的对象，定义在</strong><code>from django.db import models</code>**中</li><li>用于模型对象和数据库交互</li><li>是默认自动生成的属性，但是可以自定义管理器对象</li><li>自定义管理器对象后，Django不再生成默认管理器对象**<code>objects</code>**</li></ul><p><strong>自定义管理器对象</strong></p><p>为模型类<code>UserInfo</code>自定义管理器对象<code>Users</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 用户信息模型</span><span class="token keyword">class</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">#名称</span>    pub_date <span class="token operator">=</span> models<span class="token punctuation">.</span>DateField<span class="token punctuation">(</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#日期</span>    readcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#阅读量</span>    commentcount <span class="token operator">=</span> models<span class="token punctuation">.</span>IntegerField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#评论量</span>    isDelete <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#逻辑删除</span>     <span class="token comment">#元类信息 : 修改表名</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        db_table <span class="token operator">=</span> <span class="token string">'Userinfo'</span>     <span class="token comment"># 自定义管理器对象</span>    Users <span class="token operator">=</span> models<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义管理器对象后，查询数据时直接使用 <code>Users </code>查询,不再用默认的<code>objects</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 书籍列表信息视图</span>  <span class="token keyword">def</span> <span class="token function">userList</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment"># 查询数据库用户信息 : 默认管理器对象--objects</span>      <span class="token comment"># UserInfos = UserInfo.objects.all()</span>       <span class="token comment"># 查询数据库用户信息 : 自定义管理器对象--Users</span>     UserInfos <span class="token operator">=</span> UserInfo<span class="token punctuation">.</span>Users<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment"># 构造上下文</span>      context <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Userlist'</span><span class="token punctuation">:</span>UserInfos<span class="token punctuation">}</span>       <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'User/Userlist.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Manager：管理器类</strong></p><ul><li>定义在**<code>from django.db import models</code>**中</li><li>管理器是Django的模型进行数据库操作的接口，Django应用的每个模型都拥有至少一个管理器</li><li>Django模型支持自定义管理器类，继承自**<code>models.Manager</code>**</li><li>自定义管理器类主要用于两种情况<ul><li>(1)修改原始查询集，重写<code>get_queryset()</code>方法<ul><li>查询时，如果需要默认过滤掉某些数据，需要修改原始查询集</li></ul></li><li>(2)新增管理器方法，如创建模型对象方法<ul><li>当模型属性很多，多数字段为默认值，每次只需要给少数属性赋值时，可以新增模型初始化方法</li></ul></li></ul></li></ul><p><strong>自定义管理器类：1.修改原始查询集</strong></p><p>把<code>peopleinfo</code>表中的<code>isDelete</code>字段修改为<code>True(updata peopleinfo set isDelete=1 where id=4)</code>,但是逻辑删除字段为<code>True</code>的那条记录依然会被查询出来，这里的解决办法是自定义管理器类，重写<code>get_queryset()</code>方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from django.db import models # 自定义管理器类class PeopleInfoManager(models.Manager):    # 自定义管理器类场景一：重写get_queryset()方法    def get_queryset(self):        # 调用父类的成员语法为：super(子类型, self).成员        # 默认只查询逻辑删除字段为False的记录        return super(PeopleInfoManager, self).get_queryset().filter(isDelete=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义管理器类：2.新增管理器方法</strong></p><p>新增管理器初始化模型对象方法：只有<code>name</code>属性需要赋值，其他的字段都是默认值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># models.py -- 自定义管理器类</span> <span class="token keyword">class</span> <span class="token class-name">UserInfoManager</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Manager<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment"># 自定义管理器类场景一：重写get_queryset()方法</span>     <span class="token keyword">def</span> <span class="token function">get_queryset</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># 调用父类的成员语法为：super(子类型, self).成员</span>         <span class="token comment"># 默认只查询逻辑删除字段为False的记录</span>         <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span>UserInfoManager<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>get_queryset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>isDelete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 初始化模型对象方法</span>     <span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>         user <span class="token operator">=</span> UserInfo<span class="token punctuation">(</span><span class="token punctuation">)</span>         user<span class="token punctuation">.</span>name <span class="token operator">=</span> name         user<span class="token punctuation">.</span>pub_date <span class="token operator">=</span> <span class="token string">'1989-11-11'</span>         user<span class="token punctuation">.</span>readcount <span class="token operator">=</span> <span class="token number">0</span>         user<span class="token punctuation">.</span>commentcount <span class="token operator">=</span> <span class="token number">0</span>         user<span class="token punctuation">.</span>isDelete <span class="token operator">=</span> <span class="token boolean">False</span>         <span class="token keyword">return</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># view.py -- User列表信息视图</span><span class="token keyword">def</span> <span class="token function">UserList</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment"># 初始化模型对象：自定义管理器类后</span>    UserInfos <span class="token operator">=</span> <span class="token punctuation">[</span>        UserInfo<span class="token punctuation">.</span>user<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        UserInfo<span class="token punctuation">.</span>user<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token string">'小杰'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>     <span class="token comment"># 构造上下文</span>    context <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Userlist'</span><span class="token punctuation">:</span>UserInfos<span class="token punctuation">}</span>     <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'User/userlist.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/04/24/she-ji-mo-shi/"/>
      <url>/2021/04/24/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、MVC设计模式"><a href="#一、MVC设计模式" class="headerlink" title="一、MVC设计模式"></a>一、MVC设计模式</h3><p><code>MVC</code>是<code>Model-View-Controller</code>的缩写。其中每个单词都有其不同的含义：</p><ul><li><code>Model</code>代表数据存储层，是对数据的定义和数据的CRUD（增删改查）。<ul><li>增加(Create)、检索(Retrieve)、更新(Update)和删除(Delete)</li></ul></li><li><code>View </code>代表视图层，是系统前端显示的部分，它负责显示什么和如何进行显示。</li><li><code>Controller </code>代表控制层，负责根据从View层输入的指令来检索Model层的数据，并在该层编写代码产生结果并输出。</li></ul><img src="/2021/04/24/she-ji-mo-shi/mvc.png" alt="MVC设计模式示意图" style="zoom:80%;"><p><code>MVC</code>设计模式的请求和响应过程描述如下：</p><ul><li>用户通过浏览器发起<code>request</code>请求，<code>Controller</code>层接受请求后，同时向<code>Model</code>层和<code>View</code>层发送指令；</li><li><code>Model</code>层根据指令与数据库交互并选择相应的业务数据，然后将数据发送给<code>Controller</code>层；</li><li><code>View</code>层接受到<code>Controller</code>层的指令后，加载用户请求的界面，并将页面发送给<code>Controller</code>层；</li><li><code>Controller</code>层接收到<code>Model</code>层和<code>View</code>层的数据后，把它们组织成响应格式发送给浏览器，浏览器通过解析后把页面显示出来。</li></ul><p>​    MVC 的 3 层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC 的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是 MVC 的设计模式。</p><h3 id="二、MTV设计模式"><a href="#二、MTV设计模式" class="headerlink" title="二、MTV设计模式"></a>二、MTV设计模式</h3><p>那么 Django（栈go）的 MTV 又是怎么回事呢？下面讲解 <code>Django </code>的设计模式。</p><p>Django 借鉴了经典的 MVC 模式，它也将交互的过程分为了 3 个层次，也就是 MTV 设计模式；</p><ul><li><p><code>Model</code>：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；</p></li><li><p><code>Template</code>：模板层（也叫表现层）具体来处理页面的显示；</p></li><li><p><code>View</code>：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。</p></li></ul><img src="/2021/04/24/she-ji-mo-shi/mtv.png" alt="Django MTV设计模式示意图" style="zoom:80%;"><p>我们按照 MVC 的设计模式对 MTV 进行分析，<strong>MTV 设计模式中，用 <code>View </code>层取代了 <code>Controller</code> 层的位置，用 <code>Template</code> 层取代了原来<code>View</code>层的位置。</strong></p><p>初次接触 Django 的设计模式的人，可能会对 Template 层产生疑问，其实 Template 英文的含义就是“模板”的意思，你可以简单理解成，它是一个 HTML 页面 ，HTML 页面的渲染在视图层完成。</p><p>同样我们也对 MTV 设计模式的请求与响应过程进行描述：</p><ul><li><p>用户通过浏览器对服务器发起 <code>request </code>请求，服务器接收请求后，通过 <code>View </code>的业务逻辑层进行分析，同时向 <code>Model </code>层和 <code>Template </code>层发送指令；</p></li><li><p><code>Mole </code>层与数据库进行交互，将数据返回给 <code>View </code>层；</p></li><li><p><code>Template </code>层接收到指令后，调用相应的模板，并返回给 <code>View </code>层；</p></li><li><p><code>View </code>层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。</p></li></ul><p>​     通过以上两种设计模式的比较， 我们可以得出 <strong>MTV 是 MVC 的一种细化</strong>，将原来 MVC 中的 V 层拿出来进行分离，视图的显示与如何显示交给 Template 层，而 View 层更专注于实现业务逻辑。其实在 Django 是有 Controller 层的，只不过它由框架本身来实现，所以我们不用关心它。Django 更关注于M、T 和 V。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC </tag>
            
            <tag> MTV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/04/03/bi-bao/"/>
      <url>/2021/04/03/bi-bao/</url>
      
        <content type="html"><![CDATA[<h4 id="如何产生闭包？"><a href="#如何产生闭包？" class="headerlink" title="如何产生闭包？"></a><strong>如何产生闭包？</strong></h4><p>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。</p><h4 id="闭包到底是什么？"><a href="#闭包到底是什么？" class="headerlink" title="闭包到底是什么？"></a><strong>闭包到底是什么？</strong></h4><ol><li>使用Chrome调试查看。</li><li>理解一：闭包是嵌套的内部函数（绝大多数）。</li><li>理解二：包含被引用变量（函数）的对象（少数）。</li><li>注意：闭包存在于嵌套的内部函数中。</li></ol><h4 id="闭包产生的条件"><a href="#闭包产生的条件" class="headerlink" title="闭包产生的条件"></a>闭包产生的条件</h4><ol><li>函数嵌套。</li><li>内部函数引用了外部函数的数据（变量/函数）。</li></ol><h4 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h4><ol><li>将函数作为另一个函数的返回值。</li><li>将函数作为实参传递给另一个函数调用。</li></ol><p><code>注意</code>：外部函数执行几次，就创建几个闭包函数。因为在执行外部函数的时候，才会去创建内部函数对象，跟内部函数执行几次没有关系。</p><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ol><li>使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）。</li><li>让函数外部可以操作（读写）到函数内部的数据（变量/函数）</li></ol><p><code>问题</code>：</p><p>​            ①函数执行完后，函数内部声明的局部变量是否还存在？  一般不存在，存在于闭包中变量才有可能存在。</p><p>​            ②在函数外部能直接访问函数内部的局部变量吗？  不能，但是可以通过闭包让外部操作它。</p><h4 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h4><p><code>产生</code>：在嵌套内部函数定义执行完时就产生了（不是在调用）。</p><p><code>死亡</code>：在嵌套的内部函数成为垃圾对象时。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> fn2<span class="token punctuation">}</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 3</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 4</span>f <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">//闭包死亡（包含闭包的函数对象成为辣鸡对象）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h4><ol><li>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。</li><li>容易造成内存泄漏。</li></ol><p><code>解决方法</code>：能不用就不用；及时释放。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a><strong>内存溢出</strong></h4><ol><li><p>一种程序运行时出现的错误</p></li><li><p>当程序运行需要的内存超过了剩余的内存时，就好抛出内存溢出的错误。</p></li></ol><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><ol><li><p>占用的内存没有及时释放。</p></li><li><p>内存泄漏积累多了就容易导致内存溢出。</p></li><li><p>常见的内存泄漏：</p><p> （1）意外的全局变量；</p><p> （2）没有及时清理的计数器或回调函数；</p><p> （3）闭包；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>显示原型与隐式原型</title>
      <link href="/2021/04/03/xian-shi-yuan-xing-yu-yin-shi-yuan-xing/"/>
      <url>/2021/04/03/xian-shi-yuan-xing-yu-yin-shi-yuan-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h4><ul><li>每个函数<code>function</code>都有一个<code>prototype</code>属性，即显式原型属性。</li><li>每个实例对象都有一个<code>__proto__</code>属性，称为隐式原型属性。</li><li>对象的隐式原型的值 等于 其对应构造函数的显式原型的值。</li><li>内存结构</li><li>总结：<ul><li>函数的<code>prototype</code>属性：在定义函数时自动添加，默认指向一个空<code>Object</code>对象。<code>prototype</code>的值就是这个空对象的地址。</li><li>对象的<code>__proto__</code>属性：创建对象时自动添加，默认值为构造函数的<code>prototype</code>属性值</li><li>程序员能直接操作显式原型，不能直接操作隐式原型（ES6之前）</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//  每个函数function都有一个prototype属性，即显式原型属性,默认指向一个空的Object对象</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//内部语句：this.prototype = {} ！！重要 给当前函数对象添加prototype属性</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Object</span><span class="token comment">// 每个实例对象都有一个__proto__属性，称为隐式原型属性</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//内部语句：this.__proto__ = Fn.prototype！！！！重要</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Object</span><span class="token comment">// 对象的隐式原型的值 等于 其对应构造函数的显式原型的值（都指向这个空的Object）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>很重要的一张图！！！！！！！</strong></p><img src="/2021/04/03/xian-shi-yuan-xing-yu-yin-shi-yuan-xing/xsyx.png" alt="" style="zoom:80%;"><p><strong>实例对象分为两类：</strong></p><p>​    （1）函数（同时拥有显式原型和隐式原型属性）。</p><p>​    （2）new构造函数产生的对象。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 显示原型 </tag>
            
            <tag> 隐式原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文与执行上下文栈</title>
      <link href="/2021/04/03/zhi-xing-shang-xia-wen-yu-zhi-xing-shang-xia-wen-zhan/"/>
      <url>/2021/04/03/zhi-xing-shang-xia-wen-yu-zhi-xing-shang-xia-wen-zhan/</url>
      
        <content type="html"><![CDATA[<h4 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h4><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a><strong>变量提升</strong></h4><p>变量声明提升：通过var定义（声明）的变量，在定义语句之前就可以访问到。值为undefined。</p><p>函数声明提升：通过function声明的函数，在之前就可以调用。值为函数定义（对象）。</p><p><strong>注意</strong>：函数提升只能是采用function声明的方式，不能是函数表达式方式。</p><p><strong>变量提升和函数提升是如何产生的？</strong></p><h4 id="全局执行上下文："><a href="#全局执行上下文：" class="headerlink" title="全局执行上下文："></a><strong>全局执行上下文：</strong></h4><ol><li><p>在执行全局代码前将window确定为全局执行上下文。</p></li><li><p>对<code>全局数据</code>进行预处理。</p><ol><li><p>var定义的全局变量 ==》undefined，添加为window属性。</p></li><li><p>function声明的全局函数 ==》赋值（fun），添加为window方法。</p></li><li><p>this ==》赋值（window）</p></li></ol></li><li><p>开始执行全局代码。</p></li></ol><p><strong>注：全局执行上下文只能有一个，且一直在栈底。</strong></p><h4 id="函数执行上下文："><a href="#函数执行上下文：" class="headerlink" title="函数执行上下文："></a><strong>函数执行上下文：</strong></h4><ol><li><p>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象。</p></li><li><p>对<code>局部数据</code>进行预处理。</p><p>​    1)  形参变量 ==》赋值（实参）==》添加为执行上下文的属性。</p><p>​    2) arguments ==》赋值（实参列表），添加为执行上下文的属性。</p><p>​    3) var 定义的局部变量 ==》undefined，添加为执行上下文的属性。</p><p>​    4) function 声明的函数  ==》赋值（fun），添加为执行上下文的方法。</p><p>​    5) this ==》赋值（调用函数的对象）。</p></li><li><p>开始执行函数体代码。</p></li></ol><h4 id="执行上下文栈："><a href="#执行上下文栈：" class="headerlink" title="执行上下文栈："></a><strong>执行上下文栈：</strong></h4><ol><li>在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象。</li><li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）。</li><li>在全局执行上下文创建后，将其添加到栈中（压栈）。</li><li>在当前代码执行完后，将顶栈的对象移除（出栈）。</li><li>当所有的代码执行完后，栈中只剩下window。</li></ol><p><strong>注：函数执行的时候才将其添加到栈中。</strong></p><p>代码流程分析：</p><img src="/2021/04/03/zhi-xing-shang-xia-wen-yu-zhi-xing-shang-xia-wen-zhan/执行上下文.png" alt="" style="zoom:80%;"><p><strong>面试题：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 测试题1:先执行变量提升，在执行函数提升</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ‘function’</span><span class="token punctuation">}</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 测试题2</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>b <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span class="token comment">//测试题3</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保错，c is not a function</span><span class="token comment">//测试题3实际上是按照下面的顺序来执行的：</span><span class="token keyword">var</span> c<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>c <span class="token operator">=</span> <span class="token number">1</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 保错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行上下文 </tag>
            
            <tag> 执行上下文栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2021/04/02/yuan-xing-lian/"/>
      <url>/2021/04/02/yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><strong>函数的prototype属性</strong>（显示原型属性）</p><ul><li> 每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象）。</li><li>原型对象中有一个属性constructor，它指向函数对象。</li></ul><p><strong>给原型对象添加属性（一般都是方法）</strong></p><ul><li>作用：函数的所有实例对象自动拥有原型中的属性（方法）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Date</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token keyword">typeof</span> <span class="token class-name">Date</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{constructor: ƒ, toString: ƒ, toDateString: ƒ, toTimeString: ƒ, toISOString: ƒ, …} "object"</span><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//默认指向一个Object空对象(没有我们自己定义的属性)</span><span class="token comment">// 原型对象中有一个属性constructor，它指向函数对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Date</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Fun<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><span class="token comment">// 给原型对象添加属性（一般都是方法）===&gt;给实例对象使用</span><span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test()'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fun<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//test()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/04/02/yuan-xing-lian/yxl.png" alt="" style="zoom:80%;"><p>如上图所示，假设函数名为<code>Type</code>,它拥有<code>prototype</code>属性,并且<code>prototype</code>指向<code>Type</code>的原型对象，而原型对象里面拥有<code>constructor</code>属性，<code>constructor</code>指向<code>Type</code>。由此说明，<strong>构造函数和它的原型对象相互引用。</strong></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul><li>访问一个对象的属性时<ul><li>先在<code>自身属性</code>中查找，找到返回。</li><li>如果没有，再沿着<code>__proto__</code>这条链向上查找，找到返回。</li><li>如果最终没有找到，返回<code>undefined</code>。</li></ul></li><li>别名：隐式原型链（<strong>沿着隐式原型链查找</strong>）</li><li>作用：查找对象的属性（方法）</li></ul><p><strong>下面的代码和图很重要！！！！理解！！！！</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//内置的Object对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">test1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">test2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fn<span class="token punctuation">.</span><span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//test1</span>fn<span class="token punctuation">.</span><span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//test2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Object]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>test3<span class="token punctuation">)</span> <span class="token comment">//undefined</span>fn<span class="token punctuation">.</span><span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//加了(),就相当于把undefined当成函数去执行，执行错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/04/02/yuan-xing-lian/yxl1.png" alt="" style="zoom:80%;"><p>注意：Object是已经内置的Object对象。<strong>Object的原型对象就是原型链的尽头。</strong></p><p><strong>下面的图是执行了我们添加了的属性（方法）之后的。</strong></p><img src="/2021/04/02/yuan-xing-lian/yxl2.png" alt="" style="zoom:80%;"><p>另外，<code>Object.prototype.__proto__为null</code><strong>，也即是说，这是原型链的尽头。</strong></p><img src="/2021/04/02/yuan-xing-lian/yxl3.png" alt="" style="zoom:80%;"><p><code>Function </code>既是构造函数，又是实例对象。也就是说它是<code>new</code>自己产生的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Function <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所有函数的<code>隐式原型属性__proto__</code>属性都是一样的。因为都是new Function产生的。</p><p>构造函数 —–显式原型属性—-<code>prototype</code></p><p>实例对象 —–隐式原型属性—–<code>__proto__</code></p><p><strong>下面是一张图。很有意思！！！！！！！</strong></p><pre class="line-numbers language-none"><code class="language-none">Function Foo() {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/04/02/yuan-xing-lian/yxl4.png" alt="" style="zoom:80%;"><p>推荐观看视频：<a href="https://www.bilibili.com/video/BV14s411E7qf?p=15">https://www.bilibili.com/video/BV14s411E7qf?p=15</a></p><p><strong>总结：</strong></p><p><code>1. 函数的显式原型指向的对象默认是空Object实例对象。（但是Object不满足）</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>  <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>  <span class="token comment">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>  <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>2. 所有函数都是Function的实例（包括Function本身）。</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>3. Object的原型对象是原型链的尽头。</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>  <span class="token comment">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>属性问题：</strong></p><p>读取对象的属性时：会自动到原型链中查找。</p><p>设置对象的属性时：<strong>不会查找原型链，如果当前对象没有此属性，直接添加此属性并设置其值。</strong></p><p><strong>方法一般定义在原型链中</strong>，<strong>属性一般通过构造函数定义在对象本身上。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'aaa'</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn1<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token comment">//aaa</span><span class="token keyword">var</span> fn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fn2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'bbb'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn2<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token comment">//bbb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行机制</title>
      <link href="/2021/03/21/javascript-zhi-xing-ji-zhi/"/>
      <url>/2021/03/21/javascript-zhi-xing-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、关于JavaScript"><a href="#一、关于JavaScript" class="headerlink" title="一、关于JavaScript"></a>一、关于JavaScript</h3><p>JavaScript是一门<strong>单线程</strong>语言，在最新的HTML5中提出了Web-Worker，但JavaScript是单线程这一核心仍未改变。所以一切JavaScript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="二、JavaScript事件循环"><a href="#二、JavaScript事件循环" class="headerlink" title="二、JavaScript事件循环"></a>二、JavaScript事件循环</h3><p>既然JS是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理JS任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p><img src="/2021/03/21/javascript-zhi-xing-ji-zhi/js.png"><p>导图要表达的内容用文字来表述的话：</p><ul><li><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入<code>Event Table</code>并注册函数。</p></li><li><p>当指定的事情完成时，<code>Event Table</code>会将这个函数移入<code>Event Queue</code>。</p></li><li><p>主线程内的任务执行完毕为空，会去<code>Event Queue</code>读取对应的函数，进入主线程执行。</p></li><li><p>上述过程会不断重复，也就是常说的<code>Event Loop</code>(事件循环)。</p></li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在<code>monitoring process进程</code>，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去<code>Event Queue</code>那里检查是否有等待被调用的函数。</p><p>说了这么多文字，不如直接一段代码更直白：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token operator">:</span>www<span class="token punctuation">.</span>javascript<span class="token punctuation">.</span>com<span class="token punctuation">,</span>    data<span class="token operator">:</span>data<span class="token punctuation">,</span>    <span class="token function-variable function">success</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发送成功!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'代码执行结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是一段简易的<code>ajax</code>请求代码：</p><ul><li>ajax进入Event Table，注册回调函数<code>success</code>。</li><li>执行<code>console.log('代码执行结束')</code>。</li><li>ajax事件完成，回调函数<code>success</code>进入Event Queue。</li><li>主线程从Event Queue读取回调函数<code>success</code>并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：<code>setTimeout</code>。</p><h3 id="三、setTimeout"><a href="#三、setTimeout" class="headerlink" title="三、setTimeout"></a>三、setTimeout</h3><p>大名鼎鼎的<code>setTimeout</code>无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">setTimeout(() =&gt; {    console.log('延时3秒');},3000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渐渐的<code>setTimeout</code>用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><p>先看一个例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行console'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据前面我们的结论，<code>setTimeout</code>是异步的，应该先执行<code>console.log</code>这个同步任务，所以我们的结论是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//执行console</span><span class="token comment">//task()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行<code>task()</code>需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p><p>这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li><p><code>task()</code>进入Event Table并注册,计时开始。</p></li><li><p>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</p></li><li><p>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</p></li><li><p><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</p></li></ul><p>上述的流程走完，我们知道<code>setTimeout</code>这个函数，是经过指定时间后，把要执行的任务(本例中为<code>task()</code>)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//代码1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'先执行这里'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行啦'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//代码2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'先执行这里'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行啦'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码1的输出结果是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//先执行这里</span><span class="token comment">//执行啦</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码2的输出结果是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//先执行这里</span><span class="token comment">// ... 3s later</span><span class="token comment">// 执行啦</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p><h3 id="四、setInterval"><a href="#四、setInterval" class="headerlink" title="四、setInterval"></a>四、setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦**<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了**。这句话请读者仔细品味。</p><h3 id="五、Promise与process-nextTick-callback"><a href="#五、Promise与process-nextTick-callback" class="headerlink" title="五、Promise与process.nextTick(callback)"></a>五、Promise与process.nextTick(callback)</h3><p>传统的定时器我们已经研究过了，接着我们探究<code>Promise</code>与<code>process.nextTick(callback)</code>的表现。</p><p><code>Promise</code>的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/promise">Promise</a>。而<code>process.nextTick(callback)</code>类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p><p>我们进入正题，除了广义的<code>同步任务</code>和<code>异步任务</code>，我们对任务有更精细的定义：</p><ul><li><code>macro-task(宏任务)</code>：包括整体代码script，setTimeout，setInterval</li><li><code>micro-task(微任务)</code>：Promise，process.nextTick</li></ul><p>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</p><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'console'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>这段代码作为宏任务，进入主线程。</p></li><li><p>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</p></li><li><p>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</p></li><li><p>遇到<code>console.log()</code>，立即执行。</p></li><li><p>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</p></li><li><p>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</p></li><li><p>结束。</p></li></ul><p>事件循环，宏任务，微任务的关系如图所示：</p><img src="/2021/03/21/javascript-zhi-xing-ji-zhi/task.png" style="zoom:50%;"><p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一轮事件循环流程分析如下：</p><ul><li><p>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</p></li><li><p>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</p></li><li><p>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</p></li><li><p>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</p></li><li><p>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</p></li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout1</td><td align="center">process1</td></tr><tr><td align="center">setTimeout2</td><td align="center">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li><li>执行<code>process1</code>,输出6。</li><li>执行<code>then1</code>，输出8。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center">setTimeout2</td><td align="center">process2</td></tr><tr><td align="center"></td><td align="center">then2</td></tr></tbody></table><ul><li><p>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</p></li><li><p>输出3。</p></li><li><p>输出5。</p></li><li><p>第二轮事件循环结束，第二轮输出2，4，3，5。</p></li><li><p>第三轮事件循环开始，此时只剩setTimeout2了，执行。</p></li><li><p>直接输出9。</p></li><li><p>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</p></li><li><p>直接执行<code>new Promise</code>，输出11。</p></li><li><p>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</p></li></ul><table><thead><tr><th align="center">宏任务Event Queue</th><th align="center">微任务Event Queue</th></tr></thead><tbody><tr><td align="center"></td><td align="center">process3</td></tr><tr><td align="center"></td><td align="center">then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为<code>1，7，6，8，2，4，3，5，9，11，10，12</code>。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><h3 id="六、写在最后"><a href="#六、写在最后" class="headerlink" title="六、写在最后"></a>六、写在最后</h3><p><strong>（1）JS的异步</strong></p><p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p><p><strong>（2）事件循环Event Loop</strong></p><p>事件循环是js实现异步的一种方法，也是js的执行机制。</p><p><strong>（3）JS的执行和运行</strong></p><p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p><p><strong>（4）setImmediate</strong></p><p>微任务和宏任务还有很多种类，比如<code>setImmediate</code>等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p><p><strong>（5）最后的最后</strong></p><ul><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJANGO块标签{ %BLOCK NAME% }{ %ENDBLOCK% }的理解</title>
      <link href="/2021/03/15/django-kuai-biao-qian-block-name-endblock-de-li-jie/"/>
      <url>/2021/03/15/django-kuai-biao-qian-block-name-endblock-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>举个例子来理解吧。</p><p>（1）首先，先建立一个<code>apple.html</code>文件，内容如下:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zn-CN<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            {% block content %}            {% endblock %}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）再建立一个<code>boom.html</code>文件,内容如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">{% extend 'apple.html' %}{% block content %}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>            Django 块标签的理解        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>{% endblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么输出的网页就会变成如下。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zn-CN<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>            Django 块标签的理解        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，就是<code>boom.html</code>的块标签里面的内容完全代替了<code>apple.html</code>里面的块标签。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django  块标签  {% block name%}{endblock} </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIoT时代的智能无线感知：特征、算法、数据集</title>
      <link href="/2020/03/21/aiot-shi-dai-de-zhi-neng-wu-xian-gan-zhi/"/>
      <url>/2020/03/21/aiot-shi-dai-de-zhi-neng-wu-xian-gan-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​        人类对物理世界的感知经历了从主观感受到传感器再到传感网的发展阶段，如图1所示。在传感器变得越来越小、数据采集变得越来越普及的同时，有一个问题也日益突出——传感系统的部署成本太高。特别是随着感知范围和规模不断增大，部署和维护长期稳定运行的大规模传感系统的难度和成本也越来越高。以室内人员定位为例，虽然我们可以在特定的房间、工厂里部署定位设施和系统，但是这些特定的区域与人类活动所处的整个物理世界相比无异于九牛一毛。当我们面对全世界范围内的住宅、学校、商场、机场、写字楼时，这种部署方式就显得无能为力了。那么有没有可能突破传统思维，在不部署任何专用传感器的情况下也能感知各种环境信息呢？已有研究工作利用电视广播信号来获取能量，为低功耗物联网设备供电，受此启发，我们是否能够实现非传感器感知，利用环境中已经存在的无线射频信号（例如Wi-Fi、RFID、蓝牙、ZigBee以及广播电视信号等）来感知人的动作行为？如果可行，我们就无须在环境中部署专用的传感器，也不需要人员携带传感器。目前无线网络在全球范围内已经广泛普及，这种感知物理世界的方式将显著降低部署成本，在易用性、普适性等方面取得重要突破。</p><img src="/2020/03/21/aiot-shi-dai-de-zhi-neng-wu-xian-gan-zhi/1.png" alt="" style="zoom:80%;"><p>​        环境中已有的无线信号（声、光、射频信号等）在完成本职任务（照明、通信等）的同时，还可以“额外”用来感知环境。以射频信号为例，信号发射机产生的无线电波在传播过程中会发生直射、反射、散射等物理现象，从而形成多条传播路径。这样一来，在信号接收机处形成的多径叠加信号就携带了反映信号传播空间的信息。<strong>无线感知技术</strong>（或称为<strong>非传感器场景感知技术</strong>）通过分析无线信号在传播过程中的变化，获得信号传播空间（信道）的特性，以实现场景的感知。这里的场景既包括人的因素（是否有人以及人的位置、姿势、动作等），也包括其他外物的因素。非传感器感知提供了一种全新的物理世界感知方式，即无须部署传感器，只“复用”环境中已有的无线信号即可实现场景感知。非传感器场景感知将人类对物理世界的感知方式推动到了一个新的阶段——从以前单纯依赖部署专用传感器的方式升级为“专用”与“复用”相结合的方式。</p><p>​        无线感知技术将感知与通信合二为一，具有三个鲜明特点——“三无”：<code>(1)无传感器(sensorless)</code>，感知人和环境不再需要部署专门的传感器，这有别于无线传感网中由传感器负责感知而无线信号负责通信；<code>(2)无线(wireless)</code>，无须为通信及传感器部署有线线路；<code>(3)无接触(contactless)</code>，相较于现在市场上的各种可穿戴式智能设备，无线感知更向前迈了一步，无须用户佩戴任何设备。</p><p>​        无线感知技术的感知对象包括环境、物品和人，潜在应用十分丰富。以感知人为例，无线感知技术可以用于被动式人员感知。“被动式”在这里指的是人员不需要携带任何电子设备，用以区别传统无线定位系统中，通过定位人所携带的电子设备来定位人员，这样的方式也被称作设备非绑定的(device-free)或者非侵入式的(non-invasive)。被动式人员检测可广泛使用于各种普适计算的应用中，提供更好的基于用户位置的服务。例如，博物馆中参观者接近某个展品时自动播放展品说明，超市统计近期最受关注的商品，或者在电梯及车厢中统计乘客数量等。非传感器感知还可以作为一种新型人机交互方式，通过识别人的行为（姿势、动作以及手势等微小运动）来遥控电子设备（计算机、游戏机、智能硬件等），完成特定的功能或提供交互式体感游戏；也可以用于智慧医疗监护，检测人员的睡眠质量以及老年人的意外跌倒等。被动感知的模式还契合安全保卫应用的需求。在涉密区域监控、人员入侵检测、灾难应急响应、重要物品保护等与安全相关的应用中，需要及时发现未携带任何无线通信设备的人员（工作人员或入侵者）是否在敏感区域出现并监测他们的活动。传统安防传感器中的红外传感器或者摄像头都受到可视角度的限制，只能在一个很有限的角度内监测目标，而且不能应对烟雾、遮挡乃至视觉欺骗的情况。在电影和生活中已经出现了针对传统安防传感器局限性的人员入侵方法，而基于无线信号的非传感器感知可以有效克服此类漏洞。</p><p>​        近年来，无线感知技术引起了学术界的广泛关注。在无线网络与移动计算的著名会议与期刊（例如ACM SIGCOMM、ACM MobiCom、ACM MobiSys、IEEE INFOCOM、USENIX NSDI、IEEE/ACM ToN、IEEE JSAC、IEEE TMC）上，许多论文将无线感知从梦想带入现实，在提升感知精度、提高鲁棒性、拓展应用场景等方面做出了重要贡献。除此之外，工业界也在探索非传感器感知的产品化，在智能家居、安防监控、健康监护等方面形成了实用的产品。</p><h3 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h3><p>无线感知蓬勃发展的另一面是其在实际应用中的局限性，具体体现在<strong>特征、模型、数据集</strong>三个方面：</p><p><strong>1.有效特征湮没：信号特征与背景环境相关，导致感知结果依赖部署环境，泛化能力差、学习训练成本高。</strong>造成环境依赖性强的根本原因在于，已有研究工作提取的信号特征（例如信号幅度、相位等）严重依赖于系统部署的具体环境。因此，不同的使用环境、不同的用户，甚至同一用户的不同位置、不同朝向等都会降低感知准确性，导致完全无法实现感知。针对新环境，需要重新采集数据进行训练，造成无线感知普适性差并且学习训练成本高。但令人遗憾的是，已有的工作绝大部分都是基于环境相关的信号特征来实现的。</p><p><strong>2.识别模型粗陋：缺乏在无线信号空间对人的行为活动的精细时空建模，导致感知精度低、鲁棒性差。</strong>人的姿势、动作、行为模式具有特定的时空特征。计算机视觉方向的研究工作针对图像和视频数据对人体运动特征进行建模并识别，取得了较大突破。然而在无线信号空间，缺乏对人行为活动的精细时空建模。因此，已有的工作通常简单地使用计算机视觉领域的方法，直接在原始信号层次上进行识别，或者仅仅使用时间相关性或空间相关性，缺乏同时整合利用二者的有效手段，造成相似动作难以准确判别，在实际环境中感知精度低、鲁棒性差。</p><p><strong>3.数据集缺失：高质量公开数据集的缺失造成性能比较不客观、实验结果难复现、技术进步难积累。</strong>越来越多的研究人员认识到，高质量的数据集在提取有效特征、训练精确模型以及提升跨场景学习能力等方面会起到至关重要的作用。特别是深度学习算法的广泛使用，对数据集的规模和质量提出了更高的要求。然而目前公开的数据集非常少，且数据量不足、应用场景少，难以满足深度学习算法的需求，往往导致识别模型欠拟合、泛化能力差。高质量公开数据集的缺失造成许多研究工作陷入“自说自话”的境地——性能比较不客观、实验结果难复现、技术进步难积累。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>​        既然无线信号在传播过程中“调制”了环境信息，那么如何从接收信号中“解调”这些环境信息呢？例如：如果手机接收到的Wi-Fi信号较弱，可能是由于手机距离无线路由器较远；而如果手机接收到的Wi-Fi信号强度骤降，很可能是因为手机进入了某些特定的封闭空间如电梯等。在这个例子中，我们以接收信号强度(Received Signal Strength Indicator, RSSI)为特征，推断手机的位置和所处的环境。信号特征的选取对于感知精度、可靠性、模型泛化能力等具有关键影响。</p><p>​        在无线感知领域，RSSI的普适性使其被广泛用于无线室内定位、被动式人员检测等应用中。理论上，可将RSSI代入无线信号传播模型估算信号传播距离，也可把RSSI作为特定地点的无线信号特征“指纹”，还能通过RSSI的波动推断是否有人或其他障碍物阻挡无线链路。但在室内环境中，RSSI会因信号多径传播引起的小尺度阴影衰落而不再随传播距离增加单调递减，从而限制了测距精度。另外，多径传播也会引起信号强度波动，从而导致定位时无线信号指纹错误匹配。</p><p>​        为刻画多径传播，无线信道通常可用信道冲激响应(Channel Impulse Response, CIR)或频率响应(Channel Frequency Response, CFR)来建模[1~3]。以前精确测量CIR/CFR通常需要专业信道测量仪器，例如网络矢量分析仪。而现在，在普通Wi-Fi设备上，我们也能以信道状态信息(Channel State Information, CSI)的形式获取一个采样版本的CFR。RSSI只反映了多径叠加的总幅度，而CSI呈现了不同频率（对应不同子载波）下多径传播的幅度和相位，从而更加精确地刻画了具有频率选择性衰落特性的信道[1]。</p><p>​    <strong>相位信息</strong>是CSI区别于RSSI的一大特征。然而，受载波频率误差、采样频率偏差等因素的影响，CSI相位通常包含较多噪声。因此，CSI相位信息必须先处理再使用[4]。</p><p>​    <strong>波达角</strong>(Arrival of Angle, AoA)与<strong>飞行时间</strong>(Time of Flight, ToF)是雷达信号与声音信号定位、追踪目标时常用的两种特征。然而受多径效应与信号带宽的限制，在室内环境下准确估计经由目标反射而来的信号的AoA与ToF具有一定挑战性。已有工作[5]观察到在发射机、接收机或目标只有微小位移时，经由目标一次反射而来的信号的AoA比其他多次反射信号的AoA更加稳定，而且多次反射信号可能只在某些接收机的AoA谱上出现。因此可通过多径压缩的算法，滤除多次反射信号，获得定位目标的方位信息。此外，在多天线的基础上，可利用子载波多样性进行空间平滑，从而利用多个数据包提升AoA估计精度[6]。为了克服直接测量AoA与ToF的不精确性，最新的研究工作RIM[3]通过对天线阵列收到的CSI信息进行处理，测量移动目标的相对位移（位移方向、大小、速度等），创新性地利用无线射频信号实现了类似惯性传感器的功能，使得远距离目标追踪精度达到了8.4厘米。</p><p>​    <strong>多普勒频偏</strong>(Doppler Frequency Shift, DFS)也是一种常见的用于刻画人员活动与行为的特征，这是因为目标移动将导致经由目标反射的信号的路径长度产生变化，使得观测到的信号频率发生一定的偏移。对CSI功率进行时频分析（如短时傅里叶变换和小波变换），可从功率的动态变化中提取人体运动导致的DFS[7]。一些工作进一步观察到：只有目标的径向速度分量对应着反射路径长度的变化速率，提取到的DFS和运动速度方向、人员位置存在着一定的几何约束关系。因此，通过添加更多链路可消除速度求解的歧义性，获得完整的人员速度信息，并应用于定位、追踪、活动识别等多种场景[8]。</p><p>​    <strong>多维度信号特征的融合</strong>通常可以取得比使用单一信号特征更好的感知效果。对于许多环境，多链路条件可能过于严格，比如人们通常只在家里配置一个路由器。在只有一对收发设备的情况下，需要提取出尽可能多的参数，才能对目标进行细粒度的感知与定位。已有工作[9]将CSI建模成关于幅度衰减、DFS、ToF、AoA的函数，使用基于期望最大化的算法对多径信道的多参数进行联合估计，并利用图匹配技术得到经由目标反射路径的长度与目标的方位信息的最优解，最终实现了单链路下的分米级被动式人员追踪系统。通过配置更多的发射天线，可对反射路径的DFS、ToF、AoA和出发角(Angle of Departure, AoD)进行联合估计，进一步提升单链路下的感知精度[10]。</p><p>​    上述的信号特征都是<strong>环境依赖</strong>的——在反映人的活动的同时，也反映环境情况。然而，如果不能有效地区分人和环境的信息，场景感知的效果必将严重依赖于系统的部署环境，使得不同的使用环境、不同的用户，甚至同一用户的不同位置、不同朝向等都会降低感知准确性，还会造成感知普适性差、学习训练成本高等问题。</p><p>​    最新的解决方案是通过提取<strong>环境无依赖的信号特征</strong>，在信号特征层面上提升感知模型的泛化能力。环境无依赖的信号特征不受人员位置、朝向与背景环境等因素的影响，只反映人员活动本身的信息。通过对信号的精细建模，我们提出一种环境无依赖的信号特征——人体坐标系下速度谱(Body-coordinate Velocity Profile, BVP)[2]。如图2所示，BVP是一个三维特征，它刻画了人员在进行特定活动时信号能量在不同速度（对应产生运动的不同身体部位）下分布的变化趋势。与单纯的躯干速度(velocity)信息相比，BVP传达的信息更为丰富。而且由于其构建在以人员位置为原点、人员朝向为x轴正方向的人体坐标系中，避免了在地球坐标系下不同位置与朝向会对同一活动的速度分布产生不同影响的问题。</p><img src="/2020/03/21/aiot-shi-dai-de-zhi-neng-wu-xian-gan-zhi/2.jpg" alt="" style="zoom:80%;"><p>​    图3展示了一位用户在不同环境、不同位置、不同朝向下完成同一手势时，感知系统采集得到的三个信号特征：CSI幅度、DFS以及BVP。由于CSI主要刻画了信号传播空间的特性，受背景环境的影响，即使是同一手势对应的CSI也可能完全不同。DFS虽然在原理上体现了目标移动的特性，然而由于其只能反映目标的径向运动速度信息，不同位置或朝向依然有可能影响DFS的大小。BVP有效克服了CSI与DFS对环境的依赖性：同一手势在不同环境、不同位置、不同朝向下对应的BVP基本保持一致的变化趋势。因此，以BVP为输入的感知分类器无须重复训练、收集额外数据等操作，即可实现跨位置、跨朝向、跨环境的活动识别。</p><img src="/2020/03/21/aiot-shi-dai-de-zhi-neng-wu-xian-gan-zhi/3.jpg" alt="" style="zoom:80%;"><p>​    </p><h3 id="识别算法"><a href="#识别算法" class="headerlink" title="识别算法"></a>识别算法</h3><p>在获得人体运动特征后，机器学习方法可以解决人员行为识别问题。已有工作[4]尝试利用CSI幅度和相位信息的变化特征作为输入，使用SVM算法对环境中是否存在运动物体进行分类预测，从而实现运动物体的被动式检测。对于有明显时序特性的行为，可以利用隐马尔科夫模型刻画其时序特性[7]。然而，传统的机器学习方法往往无法处理维度过高、结构过于复杂的特征，具有一定的局限性。</p><p>随着深度学习浪潮的兴起，无线感知领域对深度学习方法进行了大量的尝试。深度学习方法在计算机视觉领域取得了巨大的成功，产生了许多精确可靠的识别模型。为了借用这些模型，绝大部分已有无线感知工作不得不将原始CSI或从CSI提取到的特征以热力图或类似的形式转化为图片，作为识别模型的输入，并将识别模型作为黑盒来对待，最终获得识别结果。然而，这种方式忽视了视觉感知与无线感知在信号层面上的区别（电磁波频率、成像方式等），缺乏在无线信号空间对行为活动的精细时空建模，造成识别模型性能欠佳。Widar3.0[2]利用卷积神经网络与循环神经网络分别挖掘输入特征BVP在空间维度与时间维度的特性，对6种常见的人机交互手势（推拉、横扫、拍手、滑动、画圆、画之字）进行判别，准确率高于90%。STFNets[11]没有使用常规的卷积神经网络和循环神经网络，而是提出了一种新的基础神经网络构建模块——短时傅里叶神经网络，来直接学习多种传感输入在频域中的特征，并发现将信号转换到频域会极大地简化学习过程。</p><p>泛化能力差是当前识别算法的另一个主要问题。泛化能力是指模型对未知数据的适应能力。对于无线感知来说，泛化能力至关重要——识别模型一旦训练好之后，就应该可以应用于千家万户，而不是到千家万户后还要用户重新采集大量数据并自己训练。为了解决跨域的识别问题，Widar3.0通过挖掘环境无依赖的信号特征来提升泛化能力。与更专注在信号层面的Widar3.0不同，EI[12]在模型设计上进行了探索——引入对抗学习的思想，通过设计更加复杂的网络结构，定义新的损失函数，在充分利用无标签数据的基础上，直接利用新的模型，学习信号特征在不同环境中的共性表达。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>高质量公开数据集对科研的推动作用是巨大的。在计算机视觉领域，ImageNet[13]等公开数据集为深度学习算法的成功奠定了数据基础。无线感知领域对高质量公开数据集的需求更加迫切，原因是无线射频信号的传播特性导致实验结果对设备的部署情况依赖性更高、对环境条件更加敏感。多伦多大学与斯坦福大学于2017年公开了一个包含4GB原始CSI信息的数据集[14]，记录了6位用户的6种活动（躺、摔倒、走路、跑步、坐下、起立）。威廉玛丽学院的研究团队于2018年公开了两种实验场景（办公室与住宅）下，6位用户用276种手语表达时对应的原始CSI数据[15]。清华大学的研究团队于2018年公开了1位用户在三个场景的80条运动轨迹数据，可用于被动式定位与追踪的研究[8,9]。然而，已有的公开数据集大都存在数据量不足、应用场景少等问题。</p><p>作者团队在这方面做了进一步探索，公开了Widar3.0的手势识别数据集1。该数据集包含原始CSI数据以及提取出的信号特征(DFS和BVP)，包括75个不同场景下（包括不同位置、朝向与环境）采集的约26万组动作实例，总时长超过144小时，数据规模约为325GB。该数据集自公布一个月之内，已有200余位来自中国、美国、日本、新加坡、澳大利亚等多个国家的用户进行访问和下载。希望该数据集的推出能让无线感知领域的研究工作变得更“容易”——站在研究最前沿并做出可信的创新结果。</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>人类对物理世界的感知进入了泛在智能的新阶段，物联网与人工智能技术共同推动人类社会从万物互联走向万物智联。2019年风靡一时的词汇“人工智能物联网”(AIoT)就是来自“人工智能”(AI)与“物联网”(IoT)两个词的结合。不同于以往，这次工业界率先预见了这一变革。华为确定了“构建万物互联的智能世界”的新愿景，小米把“AIoT”提升为核心战略，BAT等互联网公司也都提出了相似的发展战略。作为物联网与人工智能的交叉领域，无线感知正反映了这一趋势，成为当前学术界研究和工业界追寻的热点。在本领域，工业界有产品化优势，擅于将新技术融合进智能产品；学术界有创新探索的驱动力，擅于研发新技术。</p><p>其实，早在两千多年前，荀子就讨论了人类感知与智能的关系，在《荀子·正名篇》中郑重写下了“知之在人者谓之知，知有所合者谓之智”。但是，荀子肯定没能预料到“知”和“智”一旦结合起来，并且从“人”延伸到“物”，是一个怎样的泛在智能的时代。两千多年后的我们，有能力预料吗？</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Yang Z, Zhou Z, Liu Y. From RSSI to CSI: Indoor Localization via Channel Response[J]. ACM Computing Surveys, 2013, 46(2):1-32.</p><p>[2] Zheng Y, Zhang Y, Qian Kand et al. Zero-Effort Cross-Domain Gesture Recognition with Wi-Fi[C]//Proceedings of the 17th Annual International Conference on Mobile Systems, Applications, and Services (MobiSys). ACM, 2019.</p><p>[3] Wu C S, Zhang F, Fan Y, and et al. RF-based inertial measurement[C]// Proceedings of the ACM Special Interest Group on Data Communication (SIGCOMM). ACM, 2019.</p><p>[4] Qian K, Wu C, Yang Z, et al. PADS: Passive Detection of Moving Targets with Dynamic Speed using PHY Layer Information[C]// Proceedings of the 20th IEEE International Conference on Parallel and Distributed Systems (ICPADS). IEEE, 2014.</p><p>[5] Xiong J, Jamieson K. ArrayTrack: A Fine-Grained Indoor Location System[C]// Proceedings of the 10th USENIX conference on Networked Systems Design and Implementation. USENIX Association, 2013.</p><p>[6] Kotaru M, Joshi K, Bharadia D, et al. SpotFi: Decimeter Level Localization Using Wi-Fi[J]. ACM Sigcomm Computer Communication Review, 2015, 45(4):269-282.</p><p>[7] Wang W, Liu A X, Shahzad M, et al. Understanding and Modeling of Wi-Fi Signal Based Human Activity Recognition[C]// ACM MobiCom. ACM, 2015.</p><p>[8] Qian K, Wu C S, Yang Z and et al. Widar: Decimeter-level passive tracking via velocity monitoring with commodity Wi-Fi[C]//Proceedings of the 18th ACM International Symposium on Mobile Ad Hoc Networking and Computing(MobiHoc). ACM, 2017.</p><p>[9] Qian K, et al. Widar2. 0: Passive human tracking with a single wi-fi link[C]//Proceedings of the 16th Annual International Conference on Mobile Systems, Applications, and Services (MobiSys). ACM, 2018.</p><p>[10] Xie Y X, Xiong J, Li M and et al. mD-Track: Leveraging multi-dimensionality for passive indoor Wi-Fi tracking[C]//The 25th Annual International Conference on Mobile Computing and Networking (MobiCom). ACM, 2019.</p><p>[11] Yao S, Piao A, Jiang W, et al. STFNets: Learning Sensing Signals from the Time-Frequency Perspective with Short-Time Fourier Neural Networks[J]. ACM. 2019.</p><p>[12] Jiang W J, et al. Towards environment independent device free human activity recognition[C]//Proceedings of the 24th Annual International Conference on Mobile Computing and Networking (MobiCom). ACM, 2018.</p><p>[13] Deng J, Dong W, Socher R, et al. ImageNet: a Large-Scale Hierarchical Image Database[C]// 2009 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR 2009), Miami, Florida, USA. IEEE, 2009.</p><p>[14] Siamak Y, Hirokazu N,Sankalp D and et al. A survey on behavior recognition using WiFi channel state information[J].IEEE Communications Magazine. 2017, 55(10): 98-104.</p><p>[15] Ma Y S, Zhou G, Wang S Q and et al.SignFi: Sign language recognition using WiFi[C]//Proceedings of the ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies. 2018.</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>1 Widar3.0数据集下载地址：<a href="http://tns.thss.tsinghua.edu.cn/widar3.0/%E3%80%82">http://tns.thss.tsinghua.edu.cn/widar3.0/。</a></p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p><strong>杨铮</strong></p><p>CCF专业会员。清华大学副教授、博士生导师。主要研究方向为物联网，包括传感网、工业互联网、RFID、定位导航、群智感知、移动数据挖掘等。<a href="mailto:yangzheng@tsinghua.edu.cn">yangzheng@tsinghua.edu.cn</a></p><p><strong>郑月</strong></p><p>清华大学博士生。主要研究方向为无线感知。<a href="mailto:zhengyue15@mails.tsinghua.edu.cn">zhengyue15@mails.tsinghua.edu.cn</a></p><p><strong>吴陈沭</strong></p><p>马里兰大学助理研究员。主要研究方向为物联网，无线感知和定位。<a href="mailto:cswu@umd.edu">cswu@umd.edu</a></p><p>该文章针对无线感知的基本内容做了详细介绍，并给出了当前的研究难点和挑战，非常好的学习材料，特推荐各位伙伴。</p><p>本篇文件原地址：<a href="https://www.ccf.org.cn/Focus/2020-03-12/696634.shtml">https://www.ccf.org.cn/Focus/2020-03-12/696634.shtml</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
